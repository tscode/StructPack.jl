<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Formats · StructPack.jl Documentation</title><meta name="title" content="Formats · StructPack.jl Documentation"/><meta property="og:title" content="Formats · StructPack.jl Documentation"/><meta property="twitter:title" content="Formats · StructPack.jl Documentation"/><meta name="description" content="Documentation for StructPack.jl Documentation."/><meta property="og:description" content="Documentation for StructPack.jl Documentation."/><meta property="twitter:description" content="Documentation for StructPack.jl Documentation."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">StructPack.jl Documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Overview</a></li><li><a class="tocitem" href="../usage/">Usage</a></li><li class="is-active"><a class="tocitem" href>Formats</a><ul class="internal"><li><a class="tocitem" href="#Basic-formats"><span>Basic formats</span></a></li><li><a class="tocitem" href="#Vector-and-array-formats"><span>Vector and array formats</span></a></li><li><a class="tocitem" href="#Map-formats"><span>Map formats</span></a></li><li><a class="tocitem" href="#Type-formats"><span>Type formats</span></a></li><li><a class="tocitem" href="#Special-formats"><span>Special formats</span></a></li></ul></li><li><a class="tocitem" href="../context/">Context</a></li><li><a class="tocitem" href="../macro/">The @pack macro</a></li><li><a class="tocitem" href="../reference/">API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Formats</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Formats</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/tscode/StructPack.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/tscode/StructPack.jl/blob/main/docs/src/formats.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Formats"><a class="docs-heading-anchor" href="#Formats">Formats</a><a id="Formats-1"></a><a class="docs-heading-anchor-permalink" href="#Formats" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StructPack.Format" href="#StructPack.Format"><code>StructPack.Format</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Abstract format type.</p><p>Formats determine the rules for packing and unpacking values via msgpack primitives. They are supposed to be singleton types.</p><p>To add support for a new format <code>F &lt;: Format</code>, define the corresponding methods of <a href="../reference/#StructPack.pack"><code>pack</code></a> and <a href="../reference/#StructPack.unpack"><code>unpack</code></a>.</p><p>This package comes with a number of built-in formats. The following core formats have low-level implementations that build upon one or more formats of the msgpack specification:</p><ul><li><a href="#StructPack.NilFormat"><code>NilFormat</code></a> (msgpack nil),</li><li><a href="#StructPack.BoolFormat"><code>BoolFormat</code></a> (msgpack boolean),</li><li><a href="#StructPack.SignedFormat"><code>SignedFormat</code></a> (msgpack negative / positive fixint, signed 8-64),</li><li><a href="#StructPack.UnsignedFormat"><code>UnsignedFormat</code></a> (msgpack positive fixint, unsigned 8-64),</li><li><a href="#StructPack.FloatFormat"><code>FloatFormat</code></a> (msgpack float32, float64)</li><li><a href="#StructPack.StringFormat"><code>StringFormat</code></a> (msgpack fixstr, str 8-32),</li><li><a href="#StructPack.BinaryFormat"><code>BinaryFormat</code></a> (msgpack bin 16, bin 32).</li></ul><p>For vector-like and map-like objects, several built-in formats with different benefits and drawbacks are provided as subtypes of</p><ul><li><a href="#StructPack.AbstractVectorFormat"><code>AbstractVectorFormat</code></a> (msgpack fixarray, array 16, array 32),</li><li><a href="#StructPack.AbstractMapFormat"><code>AbstractMapFormat</code></a> (msgpack fixmap, map 16, map 32).</li></ul><p>Additional convenience formats include</p><ul><li><a href="#StructPack.ArrayFormat"><code>ArrayFormat</code></a> (store multidimensional arrays),</li><li><a href="#StructPack.BinVectorFormat"><code>BinVectorFormat</code></a> (store vectors with bitstype elements efficiently),</li><li><a href="#StructPack.BinArrayFormat"><code>BinArrayFormat</code></a> (store multidimensional bitstype arrays efficiently),</li><li><a href="#StructPack.TypeFormat"><code>TypeFormat</code></a> (store types)</li><li><a href="#StructPack.TypedFormat"><code>TypedFormat</code></a> (store values and their type for generic unpacking).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tscode/StructPack.jl/blob/a9d56dd776c401a668227c369fe068ca41e5d22e/src/pack.jl#L2-L36">source</a></section></article><h2 id="Basic-formats"><a class="docs-heading-anchor" href="#Basic-formats">Basic formats</a><a id="Basic-formats-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-formats" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StructPack.NilFormat" href="#StructPack.NilFormat"><code>StructPack.NilFormat</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Core format for packing nil values.</p><p>Built upon the msgpack format <code>nil</code>.</p><p><strong>Defaults</strong></p><p><a href="#StructPack.NilFormat"><code>NilFormat</code></a> is the default format of <code>Nothing</code>. Use</p><pre><code class="nohighlight hljs">format(::Type{T}) = NilFormat()</code></pre><p>or</p><pre><code class="nohighlight hljs">@pack T in NilFormat</code></pre><p>to make <a href="#StructPack.NilFormat"><code>NilFormat</code></a> the default format for type <code>T</code>. If <code>T</code> is abstract, use <code>{&lt;: T}</code> to cover all subtypes.</p><p><strong>Packing</strong></p><p>All types can be packed in <a href="#StructPack.NilFormat"><code>NilFormat</code></a>.</p><p><strong>Unpacking</strong></p><p>To support unpacking values of type <code>T</code> packed in <a href="#StructPack.NilFormat"><code>NilFormat</code></a>, implement</p><pre><code class="nohighlight hljs">construct(::Type{T}, ::Nothing, ::NilFormat)::T</code></pre><p>or make sure that the constructor <code>T()</code> is defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tscode/StructPack.jl/blob/a9d56dd776c401a668227c369fe068ca41e5d22e/src/coreformats.jl#L12-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StructPack.BoolFormat" href="#StructPack.BoolFormat"><code>StructPack.BoolFormat</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Core format for packing boolean values.</p><p>Built upon the msgpack format <code>boolean</code>.</p><p><strong>Defaults</strong></p><p><a href="#StructPack.BoolFormat"><code>BoolFormat</code></a> is the default format of <code>Bool</code>. Use</p><pre><code class="nohighlight hljs">format(::Type{T}) = BoolFormat()</code></pre><p>or</p><pre><code class="nohighlight hljs">@pack T in BoolFormat</code></pre><p>to make <a href="#StructPack.BoolFormat"><code>BoolFormat</code></a> the default format for type <code>T</code>. If <code>T</code> is abstract, use <code>{&lt;: T}</code> to cover all subtypes.</p><p><strong>Packing</strong></p><p>To support packing values of type <code>T</code> in <a href="#StructPack.BoolFormat"><code>BoolFormat</code></a>, implement</p><pre><code class="nohighlight hljs">destruct(val::T, ::BoolFormat)::Bool</code></pre><p><strong>Unpacking</strong></p><p>To support unpacking values of type <code>T</code> packed in <a href="#StructPack.BoolFormat"><code>BoolFormat</code></a>, implement</p><pre><code class="nohighlight hljs">construct(::Type{T}, ::Bool, ::BoolFormat)::T</code></pre><p>or make sure that the constructor <code>T(::Bool)</code> is defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tscode/StructPack.jl/blob/a9d56dd776c401a668227c369fe068ca41e5d22e/src/coreformats.jl#L61-L90">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StructPack.SignedFormat" href="#StructPack.SignedFormat"><code>StructPack.SignedFormat</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Core format for packing signed integer values.</p><p>Built upon the msgpack formats <code>negative fixint</code>, <code>positive fixint</code>, <code>signed 8</code>, <code>signed 16</code>, <code>signed 32</code>, <code>signed 64</code>.</p><p><strong>Defaults</strong></p><p><a href="#StructPack.SignedFormat"><code>SignedFormat</code></a> is the default format of all subtypes of <code>Signed</code>. Use</p><pre><code class="nohighlight hljs">format(::Type{T}) = SignedFormat()</code></pre><p>or</p><pre><code class="nohighlight hljs">@pack T in SignedFormat</code></pre><p>to make <a href="#StructPack.SignedFormat"><code>SignedFormat</code></a> the default format for type <code>T</code>. If <code>T</code> is abstract, use <code>{&lt;: T}</code> to cover all subtypes.</p><p><strong>Packing</strong></p><p>To support packing values of type <code>T</code> in <a href="#StructPack.SignedFormat"><code>SignedFormat</code></a>, implement</p><pre><code class="nohighlight hljs">destruct(val::T, ::SignedFormat)::Signed</code></pre><p><strong>Unpacking</strong></p><p>To support unpacking values of type <code>T</code> packed in <a href="#StructPack.SignedFormat"><code>SignedFormat</code></a>, implement</p><pre><code class="nohighlight hljs">construct(::Type{T}, ::Int64, ::SignedFormat)::T</code></pre><p>or make sure that the constructor <code>T(::Int64)</code> is defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tscode/StructPack.jl/blob/a9d56dd776c401a668227c369fe068ca41e5d22e/src/coreformats.jl#L117-L147">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StructPack.UnsignedFormat" href="#StructPack.UnsignedFormat"><code>StructPack.UnsignedFormat</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Core format for packing unsigned integer values.</p><p>Built upon the msgpack formats <code>positive fixint</code>, <code>unsigned 8</code>, <code>unsigned 16</code>, <code>unsigned 32</code>, <code>unsigned 64</code>.</p><p><strong>Defaults</strong></p><p><a href="#StructPack.UnsignedFormat"><code>UnsignedFormat</code></a> is the default format of all subtypes of <code>Unsigned</code>. Use</p><pre><code class="nohighlight hljs">format(::Type{T}) = UnsignedFormat()</code></pre><p>or</p><pre><code class="nohighlight hljs">@pack T in UnsignedFormat</code></pre><p>to make <a href="#StructPack.UnsignedFormat"><code>UnsignedFormat</code></a> the default format for type <code>T</code>. If <code>T</code> is abstract, use <code>{&lt;: T}</code> to cover all subtypes.</p><p><strong>Packing</strong></p><p>To support packing values of type <code>T</code> in <a href="#StructPack.UnsignedFormat"><code>UnsignedFormat</code></a>, implement</p><pre><code class="nohighlight hljs">destruct(val::T, ::UnsignedFormat)::Unsigned</code></pre><p><strong>Unpacking</strong></p><p>To support unpacking values of type <code>T</code> packed in <a href="#StructPack.UnsignedFormat"><code>UnsignedFormat</code></a>,  implement</p><pre><code class="nohighlight hljs">construct(::Type{T}, ::UInt64, ::UnsignedFormat)::T</code></pre><p>or make sure that the constructor <code>T(::UInt64)</code> is defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tscode/StructPack.jl/blob/a9d56dd776c401a668227c369fe068ca41e5d22e/src/coreformats.jl#L210-L240">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StructPack.FloatFormat" href="#StructPack.FloatFormat"><code>StructPack.FloatFormat</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Core format for packing float values.</p><p>Built upon the msgpack formats <code>float 32</code>, <code>float 64</code>.</p><p><strong>Defaults</strong></p><p><a href="#StructPack.FloatFormat"><code>FloatFormat</code></a> is the default format for <code>Float16</code>, <code>Float32</code>, and <code>Float64</code>. Use</p><pre><code class="nohighlight hljs">format(::Type{T}) = FloatFormat()</code></pre><p>or</p><pre><code class="nohighlight hljs">@pack T in FloatFormat</code></pre><p>to make <a href="#StructPack.FloatFormat"><code>FloatFormat</code></a> the default format for type <code>T</code>. If <code>T</code> is abstract, use <code>{&lt;: T}</code> to cover all subtypes.</p><p><strong>Packing</strong></p><p>To support packing values of type <code>T</code> in <a href="#StructPack.FloatFormat"><code>FloatFormat</code></a>, implement</p><pre><code class="nohighlight hljs">destruct(val::T, ::FloatFormat)::Union{Float16, Float32, Float64}</code></pre><p><strong>Unpacking</strong></p><p>To support unpacking values of type <code>T</code> packed in <a href="#StructPack.FloatFormat"><code>FloatFormat</code></a>,  implement</p><pre><code class="nohighlight hljs">construct(::Type{T}, ::Float64, ::FloatFormat)::T</code></pre><p>or make sure that the constructor <code>T(::Float64)</code> is defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tscode/StructPack.jl/blob/a9d56dd776c401a668227c369fe068ca41e5d22e/src/coreformats.jl#L289-L319">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StructPack.StringFormat" href="#StructPack.StringFormat"><code>StructPack.StringFormat</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Core format for packing string values.</p><p>Built upon the msgpack formats <code>fixstr</code>, <code>str 8</code>, <code>str 16</code>, <code>str 32</code>.</p><p><strong>Defaults</strong></p><p><a href="#StructPack.StringFormat"><code>StringFormat</code></a> is the default format for <code>Symbol</code> and all subtypes of <code>AbstractString</code>. Use</p><pre><code class="nohighlight hljs">format(:: Type{T}) = StringFormat()</code></pre><p>or</p><pre><code class="nohighlight hljs">@pack T in StringFormat</code></pre><p>to make <a href="#StructPack.StringFormat"><code>StringFormat</code></a> the default format for type <code>T</code>. If <code>T</code> is abstract, use <code>{&lt;: T}</code> to cover all subtypes.</p><p><strong>Packing</strong></p><p>To support packing values of type <code>T</code> in <a href="#StructPack.StringFormat"><code>StringFormat</code></a>, implement</p><pre><code class="nohighlight hljs">destruct(val::T, ::StringFormat)::R</code></pre><p>where the returned value <code>ret::R</code> must implement <code>sizeof(ret)</code> (number of bytes) as well as <code>write(io, ret)</code>.</p><p><strong>Unpacking</strong></p><p>To support unpacking values of type <code>T</code> packed in <a href="#StructPack.StringFormat"><code>StringFormat</code></a>, implement</p><pre><code class="nohighlight hljs">construct(:: Type{T}, ::String, ::StringFormat)::T</code></pre><p>or make sure that <code>convert(T, ::String)</code> is defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tscode/StructPack.jl/blob/a9d56dd776c401a668227c369fe068ca41e5d22e/src/coreformats.jl#L351-L384">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StructPack.BinaryFormat" href="#StructPack.BinaryFormat"><code>StructPack.BinaryFormat</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Core format for packing binary values.</p><p>Built upon the msgpack formats <code>bin 8</code>, <code>bin 16</code>, <code>bin 32</code>.</p><p><strong>Defaults</strong></p><p>Use</p><pre><code class="nohighlight hljs">format(::Type{T}) = BinaryFormat()</code></pre><p>or</p><pre><code class="nohighlight hljs">@pack T in BinaryFormat</code></pre><p>to make <a href="#StructPack.BinaryFormat"><code>BinaryFormat</code></a> the default format for type <code>T</code>. If <code>T</code> is abstract, use <code>{&lt;: T}</code> to cover all subtypes.</p><p><strong>Packing</strong></p><p>To support packing values of type <code>T</code> in <a href="#StructPack.BinaryFormat"><code>BinaryFormat</code></a>, implement</p><pre><code class="nohighlight hljs">destruct(val::T, ::BinaryFormat)::R</code></pre><p>where the returned value <code>ret::R</code> must implement <code>sizeof(ret)</code> (number of bytes) as well as <code>write(io, ret)</code>.</p><p><strong>Unpacking</strong></p><p>To support unpacking values of type <code>T</code> packed in <a href="#StructPack.BinaryFormat"><code>BinaryFormat</code></a>,  implement</p><pre><code class="nohighlight hljs">construct(::Type{T}, ::Vector{UInt8}, ::BinaryFormat)::T</code></pre><p>or make sure that the constructor <code>T(::Vector{UInt8})</code> is defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tscode/StructPack.jl/blob/a9d56dd776c401a668227c369fe068ca41e5d22e/src/coreformats.jl#L433-L465">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StructPack.ExtensionFormat" href="#StructPack.ExtensionFormat"><code>StructPack.ExtensionFormat</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Format for supporting the msgpack extension standard.</p><p>Built upon the msgpack formats <code>fixext 1 - 8</code> and <code>ext 8 - 32</code>.</p><p><strong>Defaults</strong></p><p>Use</p><pre><code class="nohighlight hljs">format(::Type{T}) = ExtensionFormat{I}()</code></pre><p>or </p><pre><code class="nohighlight hljs">@pack T in ExtensionFormat{I}</code></pre><p>to make <a href="#StructPack.ExtensionFormat"><code>ExtensionFormat</code></a> with msgpack extension type <code>I::Int8</code> the default format for type <code>T</code>. If <code>T</code> is abstract, use <code>{&lt;: T}</code> to cover all subtypes.</p><p><strong>Packing</strong></p><p>To support packing values of type <code>T</code> in <a href="#StructPack.ExtensionFormat"><code>ExtensionFormat</code></a>, implement</p><pre><code class="nohighlight hljs">destruct(val::T, ::ExtensionFormat{I})::R</code></pre><p>where the return value <code>ret::R</code> must implement <code>sizeof(ret)</code> (number of bytes) as well as <code>write(io, ret)</code>.</p><p><strong>Unpacking</strong></p><p>To support unpacking values of type <code>T</code> packed in <a href="#StructPack.ExtensionFormat"><code>ExtensionFormat</code></a>, implement</p><pre><code class="nohighlight hljs">construct(::Type{T}, ::Vector{UInt8}, ::ExtensionFormat{I})::T</code></pre><p>or make sure that the constructor <code>T(::Vector{UInt8})</code> is defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tscode/StructPack.jl/blob/a9d56dd776c401a668227c369fe068ca41e5d22e/src/extensionformat.jl#L24-L57">source</a></section></article><h2 id="Vector-and-array-formats"><a class="docs-heading-anchor" href="#Vector-and-array-formats">Vector and array formats</a><a id="Vector-and-array-formats-1"></a><a class="docs-heading-anchor-permalink" href="#Vector-and-array-formats" title="Permalink"></a></h2><p>Besides <a href="#StructPack.VectorFormat"><code>VectorFormat</code></a>, which directly mirrors the msgpack vector format, StructPack.jl also provides convenience formats for storing isbits-vectors and multidimensional arrays.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StructPack.AbstractVectorFormat" href="#StructPack.AbstractVectorFormat"><code>StructPack.AbstractVectorFormat</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Umbrella type for <a href="#StructPack.VectorFormat"><code>VectorFormat</code></a> and <a href="#StructPack.DynamicVectorFormat"><code>DynamicVectorFormat</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tscode/StructPack.jl/blob/a9d56dd776c401a668227c369fe068ca41e5d22e/src/pack.jl#L39-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StructPack.VectorFormat" href="#StructPack.VectorFormat"><code>StructPack.VectorFormat</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Core format for packing vector values.</p><p>Built upon the msgpack formats <code>fixarray</code>, <code>array 16</code>, <code>array 32</code>.</p><p><strong>Defaults</strong></p><p><a href="#StructPack.VectorFormat"><code>VectorFormat</code></a> is the default format for subtypes of <code>Tuple</code> and <code>AbstractVector</code>. Use</p><pre><code class="nohighlight hljs">format(::Type{T}) = VectorFormat()</code></pre><p>or</p><pre><code class="nohighlight hljs">@pack T in VectorFormat</code></pre><p>to make <a href="#StructPack.VectorFormat"><code>VectorFormat</code></a> the default format for type <code>T</code>. If <code>T</code> is abstract, use <code>{&lt;: T}</code> to cover all subtypes.</p><p><strong>Packing</strong></p><p>To support packing values of type <code>T</code> in <a href="#StructPack.VectorFormat"><code>VectorFormat</code></a>, implement</p><pre><code class="nohighlight hljs">destruct(val::T, ::VectorFormat)::R</code></pre><p>where the returned value <code>ret::R</code> must implement <code>Base.length(ret)</code> (number of entries) and must be iterable. The formats of the entries of <code>val</code> are determined via <a href="../reference/#StructPack.valueformat"><code>valueformat</code></a>, where <code>state</code> is the linear index.</p><p><strong>Unpacking</strong></p><p>To support unpacking values of type <code>T</code> packed in <a href="#StructPack.VectorFormat"><code>VectorFormat</code></a>,  implement</p><pre><code class="nohighlight hljs">construct(::Type{T}, values::Generator{T}, ::VectorFormat)::T</code></pre><p>or make sure that the constructor <code>T(values::Generator{T})</code> is defined (see <a href="../reference/#StructPack.Generator"><code>Generator</code></a>). The respective types and formats of the entries of <code>values</code> are determined via <a href="../reference/#StructPack.valuetype"><code>valuetype</code></a> and <a href="../reference/#StructPack.valueformat"><code>valueformat</code></a>, where <code>state</code> is the linear index.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>During construction, all entries of the generator <code>values</code> have to be iterated over. Since <code>Generator{T}</code> wraps a lazy map that reads from the IO source to be unpacked, not conducting the iteration before the next object is processed will interfere with unpacking of subsequent values. For the same reason, you should not store the object <code>values</code> and access it at a later time.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tscode/StructPack.jl/blob/a9d56dd776c401a668227c369fe068ca41e5d22e/src/coreformats.jl#L505-L550">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StructPack.ArrayFormat" href="#StructPack.ArrayFormat"><code>StructPack.ArrayFormat</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Format for arrays that remembers the array size.</p><p>Built upon <a href="#StructPack.VectorFormat"><code>VectorFormat</code></a>.</p><p><strong>Defaults</strong></p><p><code>ArrayFormat</code> is the default format for <code>AbstractArray</code>. Use</p><pre><code class="nohighlight hljs">format(::Type{T}) = ArrayFormat()</code></pre><p>or</p><pre><code class="nohighlight hljs">@pack T in ArrayFormat</code></pre><p>to make <code>ArrayFormat</code> the default format for type <code>T</code>. If <code>T</code> is abstract, use <code>{&lt;: T}</code> to cover all subtypes.</p><p><strong>Packing</strong></p><p>To support packing values of type <code>T</code> in <code>ArrayFormat</code>, implement</p><pre><code class="nohighlight hljs">destruct(val::T, ::ArrayFormat)::R</code></pre><p>where the returned value <code>ret::R</code> must define <code>size</code> and must be packable in <a href="#StructPack.VectorFormat"><code>VectorFormat</code></a>.</p><p><strong>Unpacking</strong></p><p>To support unpacking values of type <code>T</code> packed in <code>ArrayFormat</code>, implement</p><pre><code class="nohighlight hljs">construct(::Type{T}, ::ArrayValue{Generator{T}}, ::ArrayFormat)::T</code></pre><p>or make sure that the constructor <code>T(val::ArrayValue{Generator{T}})</code> is defined (see <a href="../reference/#StructPack.ArrayValue"><code>ArrayValue</code></a> and <a href="../reference/#StructPack.Generator"><code>Generator</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tscode/StructPack.jl/blob/a9d56dd776c401a668227c369fe068ca41e5d22e/src/arrayformats.jl#L2-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StructPack.BinVectorFormat" href="#StructPack.BinVectorFormat"><code>StructPack.BinVectorFormat</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Pack vectors in binary format.  </p><p>Built upon <a href="#StructPack.BinaryFormat"><code>BinaryFormat</code></a>.</p><p><strong>Defaults</strong></p><p><code>BinVectorFormat</code> is the default format for <code>BitVector</code>. Use</p><pre><code class="nohighlight hljs">format(::Type{T}) = BinVectorFormat()</code></pre><p>or</p><pre><code class="nohighlight hljs">@pack T in BinVectorFormat</code></pre><p>to make <code>BinVectorFormat</code> the default format for type <code>T</code>. If <code>T</code> is abstract, use <code>{&lt;: T}</code> to cover all subtypes.</p><p><strong>Packing</strong></p><p>To support packing values of type <code>T</code> in <code>BinVectorFormat</code>, implement</p><pre><code class="nohighlight hljs">destruct(val::T, ::BinVectorFormat)::R</code></pre><p>where the returned value <code>ret::R</code> must be packable in <a href="#StructPack.BinaryFormat"><code>BinaryFormat</code></a>.</p><p><strong>Unpacking</strong></p><p>To support unpacking values of type <code>T</code> packed in <code>BinVectorFormat</code>, implement</p><pre><code class="nohighlight hljs">construct(::Type{T}, ::Vector{UInt8}, ::BinVectorFormat)::T</code></pre><p>or make sure that the constructor <code>T(bytes::Vector{UInt8})</code> is defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tscode/StructPack.jl/blob/a9d56dd776c401a668227c369fe068ca41e5d22e/src/arrayformats.jl#L61-L91">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StructPack.BinArrayFormat" href="#StructPack.BinArrayFormat"><code>StructPack.BinArrayFormat</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Pack arrays in binary format.  </p><p>Built upon <a href="#StructPack.BinVectorFormat"><code>BinVectorFormat</code></a>.</p><p><strong>Defaults</strong></p><p><code>BinArrayFormat</code> is the default format for <code>BitArray{N}</code> for <code>N &gt; 1</code>. Use</p><pre><code class="nohighlight hljs">format(::Type{T}) = BinArrayFormat()</code></pre><p>or</p><pre><code class="nohighlight hljs">@pack T in BinArrayFormat</code></pre><p>to make <code>BinVectorFormat</code> the default format for type <code>T</code>. If <code>T</code> is abstract, use <code>{&lt;: T}</code> to cover all subtypes.</p><p><strong>Packing</strong></p><p>To support packing values of type <code>T</code> in <code>BinArrayFormat</code>, implement</p><pre><code class="nohighlight hljs">destruct(val::T, ::BinArrayFormat)::R</code></pre><p>where the returned value <code>ret::R</code> must define <code>Base.size</code> and must be packable in <a href="#StructPack.BinaryFormat"><code>BinaryFormat</code></a>.</p><p><strong>Unpacking</strong></p><p>To support unpacking values of type <code>T</code> packed in <code>BinArrayFormat</code>, implement</p><pre><code class="nohighlight hljs">construct(::Type{T}, ::BinArrayValue{Vector{UInt8}}, ::BinArrayFormat)::T</code></pre><p>or make sure that the constructor <code>T(val::BinArrayValue{Vector{UInt8}})</code> is defined (see [<code>BinArrayValue</code>(@ref)]).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tscode/StructPack.jl/blob/a9d56dd776c401a668227c369fe068ca41e5d22e/src/arrayformats.jl#L104-L136">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StructPack.DynamicVectorFormat" href="#StructPack.DynamicVectorFormat"><code>StructPack.DynamicVectorFormat</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Modification of <a href="#StructPack.VectorFormat"><code>VectorFormat</code></a>.</p><p>During unpacking, the types and formats of future entries may depend on past entries via overloading <a href="../reference/#StructPack.iterstate"><code>iterstate</code></a>.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p><a href="#StructPack.DynamicVectorFormat"><code>DynamicVectorFormat</code></a> is currently slower than <a href="#StructPack.VectorFormat"><code>VectorFormat</code></a>, even if <a href="../reference/#StructPack.iterstate"><code>iterstate</code></a> just enumerates indices. In principle, however, the compiler should have all information neccessary to optimize <a href="#StructPack.DynamicVectorFormat"><code>DynamicVectorFormat</code></a> in this case and bring the performance on par. In the future, we might thus deprecate <a href="#StructPack.DynamicVectorFormat"><code>DynamicVectorFormat</code></a> and absorb its functionality into <a href="#StructPack.VectorFormat"><code>VectorFormat</code></a>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tscode/StructPack.jl/blob/a9d56dd776c401a668227c369fe068ca41e5d22e/src/dynamicformats.jl#L41-L56">source</a></section></article><h2 id="Map-formats"><a class="docs-heading-anchor" href="#Map-formats">Map formats</a><a id="Map-formats-1"></a><a class="docs-heading-anchor-permalink" href="#Map-formats" title="Permalink"></a></h2><p>Besides <a href="#StructPack.MapFormat"><code>MapFormat</code></a>, which directly mirrors the msgpack map format, StructPack.jl also provides specialized map implementations for structures.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StructPack.AbstractMapFormat" href="#StructPack.AbstractMapFormat"><code>StructPack.AbstractMapFormat</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Umbrella type for <a href="#StructPack.MapFormat"><code>MapFormat</code></a>, <a href="#StructPack.DynamicMapFormat"><code>DynamicMapFormat</code></a>, and <a href="#StructPack.AbstractStructFormat"><code>AbstractStructFormat</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tscode/StructPack.jl/blob/a9d56dd776c401a668227c369fe068ca41e5d22e/src/pack.jl#L44-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StructPack.MapFormat" href="#StructPack.MapFormat"><code>StructPack.MapFormat</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Core format for packing map / dictionary values.</p><p>Built upon the msgpack formats <code>fixmap</code>, <code>map 16</code>, <code>map 32</code>.</p><p><strong>Defaults</strong></p><p><a href="#StructPack.MapFormat"><code>MapFormat</code></a> is the default format for subtypes of <code>NamedTuple</code> and <code>Dict</code>. Use</p><pre><code class="nohighlight hljs">format(::Type{T}) = MapFormat()</code></pre><p>or</p><pre><code class="nohighlight hljs">@pack T in MapFormat</code></pre><p>to make <a href="#StructPack.MapFormat"><code>MapFormat</code></a> the default format for type <code>T</code>. If <code>T</code> is abstract, use <code>{&lt;: T}</code> to cover all subtypes.</p><p><strong>Packing</strong></p><p>To support packing values of type <code>T</code> in <a href="#StructPack.MapFormat"><code>MapFormat</code></a>, implement</p><pre><code class="nohighlight hljs">destruct(val::T, ::MapFormat)::R</code></pre><p>where the returned value <code>ret::R</code> must implement <code>Base.length(ret)</code> (number of entries) and must be iterable with key-value pairs as entries. The key / value formats of the entries of <code>val</code> are determined via <a href="../reference/#StructPack.keyformat"><code>keyformat</code></a> and <a href="../reference/#StructPack.valueformat"><code>valueformat</code></a>, where <code>state</code> is the linear index.</p><p><strong>Unpacking</strong></p><p>To support unpacking values of type <code>T</code> packed in <a href="#StructPack.MapFormat"><code>MapFormat</code></a>,  implement</p><pre><code class="nohighlight hljs">construct(::Type{T}, pairs::Generator{T}, ::MapFormat)::T</code></pre><p>or make sure that the constructor <code>T(pairs::Generator{T})</code> is defined (see <a href="../reference/#StructPack.Generator"><code>Generator</code></a>), where <code>pairs</code> will contain key-value pairs as entries. The respective types and formats of the keys and values are determined during unpacking via <a href="../reference/#StructPack.keytype"><code>keytype</code></a>, <a href="../reference/#StructPack.valuetype"><code>valuetype</code></a>, <a href="../reference/#StructPack.keyformat"><code>keyformat</code></a> and <a href="../reference/#StructPack.valueformat"><code>valueformat</code></a>, where <code>state</code> is the linear index.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>During construction, all entries of the generator <code>pairs</code> have to be iterated over. Since <code>Generator{T}</code> wraps a lazy map that reads from the IO source to be unpacked, not conducting the iteration before the next object is processed will interfere with unpacking of subsequent values. For the same reason, you should not store the object <code>pairs</code> and access it at a later time.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tscode/StructPack.jl/blob/a9d56dd776c401a668227c369fe068ca41e5d22e/src/coreformats.jl#L618-L665">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StructPack.DynamicMapFormat" href="#StructPack.DynamicMapFormat"><code>StructPack.DynamicMapFormat</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Modification of <a href="#StructPack.MapFormat"><code>MapFormat</code></a>.</p><p>During unpacking, the types and formats of future entries may depend on past entries via overloading <a href="../reference/#StructPack.iterstate"><code>iterstate</code></a>.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p><a href="#StructPack.DynamicMapFormat"><code>DynamicMapFormat</code></a> is currently slower than <a href="#StructPack.MapFormat"><code>MapFormat</code></a>, even if <a href="../reference/#StructPack.iterstate"><code>iterstate</code></a> just enumerates indices. In principle, however, the compiler should have all information neccessary to optimize <a href="#StructPack.DynamicMapFormat"><code>DynamicMapFormat</code></a> in this case and bring the performance on par. In the future, we might thus deprecate <a href="#StructPack.DynamicMapFormat"><code>DynamicMapFormat</code></a> and absorb its functionality into <a href="#StructPack.MapFormat"><code>MapFormat</code></a>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tscode/StructPack.jl/blob/a9d56dd776c401a668227c369fe068ca41e5d22e/src/dynamicformats.jl#L84-L98">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StructPack.AbstractStructFormat" href="#StructPack.AbstractStructFormat"><code>StructPack.AbstractStructFormat</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Umbrella type for <a href="#StructPack.StructFormat"><code>StructFormat</code></a>, <a href="#StructPack.UnorderedStructFormat"><code>UnorderedStructFormat</code></a>, and <a href="#StructPack.FlexibleStructFormat"><code>FlexibleStructFormat</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tscode/StructPack.jl/blob/a9d56dd776c401a668227c369fe068ca41e5d22e/src/structformat.jl#L2-L4">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StructPack.StructFormat" href="#StructPack.StructFormat"><code>StructPack.StructFormat</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Format for packing structures.</p><p>Built upon the msgpack formats <code>fixmap</code>, <code>map 16</code>, <code>map 32</code>.</p><p><strong>Defaults</strong></p><p><a href="#StructPack.StructFormat"><code>StructFormat</code></a> is not used as default for any type. However, it should be the first candidate when you want to pack custom structs. Use</p><pre><code class="nohighlight hljs">format(::Type{T}) = StructFormat()</code></pre><p>or</p><pre><code class="nohighlight hljs">@pack T in StructFormat</code></pre><p>to make <a href="#StructPack.StructFormat"><code>StructFormat</code></a> the default format for type <code>T</code>. If <code>T</code> is abstract, use <code>{&lt;: T}</code> to cover all subtypes.</p><p><strong>Packing</strong></p><p>To support packing values of type <code>T</code> in <a href="#StructPack.StructFormat"><code>StructFormat</code></a>, implement</p><pre><code class="nohighlight hljs">destruct(val::T, ::MapFormat)::R</code></pre><p>where the returned value <code>ret::R</code> must implement <code>Base.length(ret)</code> (number of entries) and must be iterable with key-value pairs as entries.</p><p>In contrast to <a href="#StructPack.MapFormat"><code>MapFormat</code></a>, the keys are always stored in <a href="#StructPack.StringFormat"><code>StringFormat</code></a> and the value formats are determined via <a href="../reference/#StructPack.fieldformats"><code>fieldformats</code></a>, which should return a tuple of formats for the value-entries of the struct.</p><p><strong>Unpacking</strong></p><p>To support unpacking values of type <code>T</code> packed in <a href="#StructPack.StructFormat"><code>StructFormat</code></a>,  implement</p><pre><code class="nohighlight hljs">construct(::Type{T}, pairs::Generator{T}, ::StructFormat)::T</code></pre><p>or make sure that the constructor <code>T(values...)</code> is defined, where <code>values</code> contains the value-entries of <code>pairs</code>.</p><p>The respective types and formats of the values are determined during unpacking via <a href="../reference/#StructPack.fieldtypes"><code>fieldtypes</code></a> and <a href="../reference/#StructPack.fieldformats"><code>fieldformats</code></a>, which should return tuples of types and formats. Additionally, <a href="../reference/#StructPack.fieldnames"><code>fieldnames</code></a> is queried to make sure the keys encountered during unpacking are consistent with <code>T</code>.</p><div class="admonition is-info"><header class="admonition-header">StructFormat vs. MapFormat</header><div class="admonition-body"><p>Both <a href="#StructPack.StructFormat"><code>StructFormat</code></a> and <a href="#StructPack.MapFormat"><code>MapFormat</code></a> can be used to pack custom structs. They perform comparably.</p><ul><li><p><a href="#StructPack.MapFormat"><code>MapFormat</code></a> is more flexible and can handle keys that are not symbols. In contrast, <a href="#StructPack.StructFormat"><code>StructFormat</code></a> requires static fieldtype, fieldname, and fieldformat information.</p></li><li><p>However, <a href="#StructPack.MapFormat"><code>MapFormat</code></a> will not counter-check key values during unpacking and can thus easily lead to corrupted data if applied on external msgpack binaries.</p></li></ul></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tscode/StructPack.jl/blob/a9d56dd776c401a668227c369fe068ca41e5d22e/src/structformat.jl#L52-L106">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StructPack.UnorderedStructFormat" href="#StructPack.UnorderedStructFormat"><code>StructPack.UnorderedStructFormat</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Modification of <a href="#StructPack.StructFormat"><code>StructFormat</code></a>.</p><p>This map-based format automatically sorts entries according to <a href="../reference/#StructPack.fieldnames"><code>fieldnames</code></a> during unpacking.</p><p>While the unpacking performance is deteriorated compared to <a href="#StructPack.StructFormat"><code>StructFormat</code></a>, this format makes it possible to load msgpack binaries where the order of map-entries cannot be guaranteed.</p><p>By default, the constructor <code>T(values...)</code> is used when unpacking a type <code>T</code> in <a href="#StructPack.UnorderedStructFormat"><code>UnorderedStructFormat</code></a>, where <code>values</code> denotes the value-entries unpacked from the msgpack map. To use a keyword-argument based constructor, simply define</p><pre><code class="nohighlight hljs">construct(::Type{T}, pairs, ::UnorderedStructFormat) = T(; pairs...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tscode/StructPack.jl/blob/a9d56dd776c401a668227c369fe068ca41e5d22e/src/structformat.jl#L128-L143">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StructPack.FlexibleStructFormat" href="#StructPack.FlexibleStructFormat"><code>StructPack.FlexibleStructFormat</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Modification of <a href="#StructPack.StructFormat"><code>StructFormat</code></a>.</p><p>When unpacking a value in map format, this format ignores superfluous fields and supports reading only a subset of the fields of a struct.</p><p>By default, the keyword argument based constructor <code>T(; pairs...)</code> is used when unpacking a type <code>T</code> in <a href="#StructPack.FlexibleStructFormat"><code>FlexibleStructFormat</code></a>, where <code>pairs</code> denotes the entries unpacked from the msgpack map.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tscode/StructPack.jl/blob/a9d56dd776c401a668227c369fe068ca41e5d22e/src/structformat.jl#L175-L183">source</a></section></article><h2 id="Type-formats"><a class="docs-heading-anchor" href="#Type-formats">Type formats</a><a id="Type-formats-1"></a><a class="docs-heading-anchor-permalink" href="#Type-formats" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StructPack.TypeFormat" href="#StructPack.TypeFormat"><code>StructPack.TypeFormat</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Format that is used for packing types.</p><p>In order to pack and unpack a type <code>T::Type</code> in <code>TypeFormat</code>, make sure that <code>t = StructPack.TypeValue(T)</code> works and that <code>StructPack.composetype(t)</code> successfully reconstructs <code>T</code>.</p><p>If <code>T</code> has type parameters, their serialization can be influenced via the functions <a href="../reference/#StructPack.typeparamtypes"><code>typeparamtypes</code></a> and <a href="../reference/#StructPack.typeparamformats"><code>typeparamformats</code></a>.</p><p>By default, all type parameters are packed / unpacked in <a href="#StructPack.TypedFormat"><code>TypedFormat</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tscode/StructPack.jl/blob/a9d56dd776c401a668227c369fe068ca41e5d22e/src/typedformat.jl#L137-L148">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StructPack.TypedFormat" href="#StructPack.TypedFormat"><code>StructPack.TypedFormat</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Wrapper format for storing the value and type of an object.</p><p>If a value <code>val::T</code> can be packed in the format <code>F&lt;:Format</code> and its type <code>T</code> can be packed in <a href="#StructPack.TypeFormat"><code>TypeFormat</code></a>, then packing <code>val</code> in <code>TypedFormat{F}</code> enables unpacking via <code>unpack(io, TypedFormat{F}())</code>, i.e., without knowledge of <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tscode/StructPack.jl/blob/a9d56dd776c401a668227c369fe068ca41e5d22e/src/typedformat.jl#L251-L258">source</a></section></article><h2 id="Special-formats"><a class="docs-heading-anchor" href="#Special-formats">Special formats</a><a id="Special-formats-1"></a><a class="docs-heading-anchor-permalink" href="#Special-formats" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StructPack.DefaultFormat" href="#StructPack.DefaultFormat"><code>StructPack.DefaultFormat</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Special format that serves as lazy placeholder for <code>format(T)</code> in situations where the type <code>T</code> is not yet known.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Never define <code>format(T)</code> for a type <code>T</code> in terms of <code>DefaultFormat</code>. This will lead to indefinite recursion.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tscode/StructPack.jl/blob/a9d56dd776c401a668227c369fe068ca41e5d22e/src/pack.jl#L274-L282">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StructPack.AnyFormat" href="#StructPack.AnyFormat"><code>StructPack.AnyFormat</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Convenience format to unpack generic msgpack values.</p><p>Note that custom contexts (see <a href="../context/#Context"><code>Context</code></a>) are ignored by <a href="#StructPack.AnyFormat"><code>AnyFormat</code></a>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The msgpack timestamp format is currently not supported by <a href="#StructPack.AnyFormat"><code>AnyFormat</code></a>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tscode/StructPack.jl/blob/a9d56dd776c401a668227c369fe068ca41e5d22e/src/anyformat.jl#L2-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="StructPack.SetContextFormat" href="#StructPack.SetContextFormat"><code>StructPack.SetContextFormat</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Special format that overrides the current context.</p><p>In particular, packing (or similarly unpacking) via</p><pre><code class="nohighlight hljs">pack(val, SetContextFormat{C, F}(), C2())</code></pre><p>is equivalent to</p><pre><code class="nohighlight hljs">pack(val, F(), C())</code></pre><p>where the original context <code>C2 &lt;: Context</code> is ignored.</p><p>This format is for example useful in combination with <a href="../reference/#StructPack.fieldformats"><code>fieldformats</code></a>, to enforce that different fields of a struct can be packed / unpacked with different contexts.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/tscode/StructPack.jl/blob/a9d56dd776c401a668227c369fe068ca41e5d22e/src/specialformats.jl#L2-L16">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../usage/">« Usage</a><a class="docs-footer-nextpage" href="../context/">Context »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Wednesday 22 January 2025 15:53">Wednesday 22 January 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
