var documenterSearchIndex = {"docs":
[{"location":"formats/","page":"Formats","title":"Formats","text":"CurrentModule = StructPack","category":"page"},{"location":"formats/#Formats","page":"Formats","title":"Formats","text":"","category":"section"},{"location":"formats/","page":"Formats","title":"Formats","text":"Format","category":"page"},{"location":"formats/#StructPack.Format","page":"Formats","title":"StructPack.Format","text":"Abstract format type.\n\nFormats determine the rules for packing and unpacking values via msgpack primitives. They are supposed to be singleton types.\n\nTo add support for a new format F <: Format, define the corresponding methods of pack and unpack.\n\nThis package comes with a number of built-in formats. The following core formats have low-level implementations that build upon one or more formats of the msgpack specification:\n\nNilFormat (msgpack nil),\nBoolFormat (msgpack boolean),\nSignedFormat (msgpack negative / positive fixint, signed 8-64),\nUnsignedFormat (msgpack positive fixint, unsigned 8-64),\nFloatFormat (msgpack float32, float64)\nStringFormat (msgpack fixstr, str 8-32),\nBinaryFormat (msgpack bin 16, bin 32).\n\nFor vector-like and map-like objects, several built-in formats with different benefits and drawbacks are provided as subtypes of\n\nAbstractVectorFormat (msgpack fixarray, array 16, array 32),\nAbstractMapFormat (msgpack fixmap, map 16, map 32).\n\nAdditional convenience formats include\n\nArrayFormat (store multidimensional arrays),\nBinVectorFormat (store vectors with bitstype elements efficiently),\nBinArrayFormat (store multidimensional bitstype arrays efficiently),\nTypeFormat (store types)\nTypedFormat (store values and their type for generic unpacking).\n\n\n\n\n\n","category":"type"},{"location":"formats/#Basic-formats","page":"Formats","title":"Basic formats","text":"","category":"section"},{"location":"formats/","page":"Formats","title":"Formats","text":"NilFormat\nBoolFormat\nSignedFormat\nUnsignedFormat\nFloatFormat\nStringFormat\nBinaryFormat\nExtensionFormat","category":"page"},{"location":"formats/#StructPack.NilFormat","page":"Formats","title":"StructPack.NilFormat","text":"Core format for packing nil values.\n\nBuilt upon the msgpack format nil.\n\nDefaults\n\nNilFormat is the default format of Nothing. Use\n\nformat(::Type{T}) = NilFormat()\n\nor\n\n@pack T in NilFormat\n\nto make NilFormat the default format for type T. If T is abstract, use {<: T} to cover all subtypes.\n\nPacking\n\nAll types can be packed in NilFormat.\n\nUnpacking\n\nTo support unpacking values of type T packed in NilFormat, implement\n\nconstruct(::Type{T}, ::Nothing, ::NilFormat)::T\n\nor make sure that the constructor T() is defined.\n\n\n\n\n\n","category":"type"},{"location":"formats/#StructPack.BoolFormat","page":"Formats","title":"StructPack.BoolFormat","text":"Core format for packing boolean values.\n\nBuilt upon the msgpack format boolean.\n\nDefaults\n\nBoolFormat is the default format of Bool. Use\n\nformat(::Type{T}) = BoolFormat()\n\nor\n\n@pack T in BoolFormat\n\nto make BoolFormat the default format for type T. If T is abstract, use {<: T} to cover all subtypes.\n\nPacking\n\nTo support packing values of type T in BoolFormat, implement\n\ndestruct(val::T, ::BoolFormat)::Bool\n\nUnpacking\n\nTo support unpacking values of type T packed in BoolFormat, implement\n\nconstruct(::Type{T}, ::Bool, ::BoolFormat)::T\n\nor make sure that the constructor T(::Bool) is defined.\n\n\n\n\n\n","category":"type"},{"location":"formats/#StructPack.SignedFormat","page":"Formats","title":"StructPack.SignedFormat","text":"Core format for packing signed integer values.\n\nBuilt upon the msgpack formats negative fixint, positive fixint, signed 8, signed 16, signed 32, signed 64.\n\nDefaults\n\nSignedFormat is the default format of all subtypes of Signed. Use\n\nformat(::Type{T}) = SignedFormat()\n\nor\n\n@pack T in SignedFormat\n\nto make SignedFormat the default format for type T. If T is abstract, use {<: T} to cover all subtypes.\n\nPacking\n\nTo support packing values of type T in SignedFormat, implement\n\ndestruct(val::T, ::SignedFormat)::Signed\n\nUnpacking\n\nTo support unpacking values of type T packed in SignedFormat, implement\n\nconstruct(::Type{T}, ::Int64, ::SignedFormat)::T\n\nor make sure that the constructor T(::Int64) is defined.\n\n\n\n\n\n","category":"type"},{"location":"formats/#StructPack.UnsignedFormat","page":"Formats","title":"StructPack.UnsignedFormat","text":"Core format for packing unsigned integer values.\n\nBuilt upon the msgpack formats positive fixint, unsigned 8, unsigned 16, unsigned 32, unsigned 64.\n\nDefaults\n\nUnsignedFormat is the default format of all subtypes of Unsigned. Use\n\nformat(::Type{T}) = UnsignedFormat()\n\nor\n\n@pack T in UnsignedFormat\n\nto make UnsignedFormat the default format for type T. If T is abstract, use {<: T} to cover all subtypes.\n\nPacking\n\nTo support packing values of type T in UnsignedFormat, implement\n\ndestruct(val::T, ::UnsignedFormat)::Unsigned\n\nUnpacking\n\nTo support unpacking values of type T packed in UnsignedFormat,  implement\n\nconstruct(::Type{T}, ::UInt64, ::UnsignedFormat)::T\n\nor make sure that the constructor T(::UInt64) is defined.\n\n\n\n\n\n","category":"type"},{"location":"formats/#StructPack.FloatFormat","page":"Formats","title":"StructPack.FloatFormat","text":"Core format for packing float values.\n\nBuilt upon the msgpack formats float 32, float 64.\n\nDefaults\n\nFloatFormat is the default format for Float16, Float32, and Float64. Use\n\nformat(::Type{T}) = FloatFormat()\n\nor\n\n@pack T in FloatFormat\n\nto make FloatFormat the default format for type T. If T is abstract, use {<: T} to cover all subtypes.\n\nPacking\n\nTo support packing values of type T in FloatFormat, implement\n\ndestruct(val::T, ::FloatFormat)::Union{Float16, Float32, Float64}\n\nUnpacking\n\nTo support unpacking values of type T packed in FloatFormat,  implement\n\nconstruct(::Type{T}, ::Float64, ::FloatFormat)::T\n\nor make sure that the constructor T(::Float64) is defined.\n\n\n\n\n\n","category":"type"},{"location":"formats/#StructPack.StringFormat","page":"Formats","title":"StructPack.StringFormat","text":"Core format for packing string values.\n\nBuilt upon the msgpack formats fixstr, str 8, str 16, str 32.\n\nDefaults\n\nStringFormat is the default format for Symbol and all subtypes of AbstractString. Use\n\nformat(:: Type{T}) = StringFormat()\n\nor\n\n@pack T in StringFormat\n\nto make StringFormat the default format for type T. If T is abstract, use {<: T} to cover all subtypes.\n\nPacking\n\nTo support packing values of type T in StringFormat, implement\n\ndestruct(val::T, ::StringFormat)::R\n\nwhere the returned value ret::R must implement sizeof(ret) (number of bytes) as well as write(io, ret).\n\nUnpacking\n\nTo support unpacking values of type T packed in StringFormat, implement\n\nconstruct(:: Type{T}, ::String, ::StringFormat)::T\n\nor make sure that convert(T, ::String) is defined.\n\n\n\n\n\n","category":"type"},{"location":"formats/#StructPack.BinaryFormat","page":"Formats","title":"StructPack.BinaryFormat","text":"Core format for packing binary values.\n\nBuilt upon the msgpack formats bin 8, bin 16, bin 32.\n\nDefaults\n\nUse\n\nformat(::Type{T}) = BinaryFormat()\n\nor\n\n@pack T in BinaryFormat\n\nto make BinaryFormat the default format for type T. If T is abstract, use {<: T} to cover all subtypes.\n\nPacking\n\nTo support packing values of type T in BinaryFormat, implement\n\ndestruct(val::T, ::BinaryFormat)::R\n\nwhere the returned value ret::R must implement sizeof(ret) (number of bytes) as well as write(io, ret).\n\nUnpacking\n\nTo support unpacking values of type T packed in BinaryFormat,  implement\n\nconstruct(::Type{T}, ::Vector{UInt8}, ::BinaryFormat)::T\n\nor make sure that the constructor T(::Vector{UInt8}) is defined.\n\n\n\n\n\n","category":"type"},{"location":"formats/#StructPack.ExtensionFormat","page":"Formats","title":"StructPack.ExtensionFormat","text":"Format for supporting the msgpack extension standard.\n\nBuilt upon the msgpack formats fixext 1 - 8 and ext 8 - 32.\n\nDefaults\n\nUse\n\nformat(::Type{T}) = ExtensionFormat{I}()\n\nor \n\n@pack T in ExtensionFormat{I}\n\nto make ExtensionFormat with msgpack extension type I::Int8 the default format for type T. If T is abstract, use {<: T} to cover all subtypes.\n\nPacking\n\nTo support packing values of type T in ExtensionFormat, implement\n\ndestruct(val::T, ::ExtensionFormat{I})::R\n\nwhere the return value ret::R must implement sizeof(ret) (number of bytes) as well as write(io, ret).\n\nUnpacking\n\nTo support unpacking values of type T packed in ExtensionFormat, implement\n\nconstruct(::Type{T}, ::Vector{UInt8}, ::ExtensionFormat{I})::T\n\nor make sure that the constructor T(::Vector{UInt8}) is defined.\n\n\n\n\n\n","category":"type"},{"location":"formats/#Vector-and-array-formats","page":"Formats","title":"Vector and array formats","text":"","category":"section"},{"location":"formats/","page":"Formats","title":"Formats","text":"Besides VectorFormat, which directly mirrors the msgpack vector format, StructPack.jl also provides convenience formats for storing isbits-vectors and multidimensional arrays.","category":"page"},{"location":"formats/","page":"Formats","title":"Formats","text":"AbstractVectorFormat\nVectorFormat\nArrayFormat\nBinVectorFormat\nBinArrayFormat\nDynamicVectorFormat","category":"page"},{"location":"formats/#StructPack.AbstractVectorFormat","page":"Formats","title":"StructPack.AbstractVectorFormat","text":"Umbrella type for VectorFormat and DynamicVectorFormat.\n\n\n\n\n\n","category":"type"},{"location":"formats/#StructPack.VectorFormat","page":"Formats","title":"StructPack.VectorFormat","text":"Core format for packing vector values.\n\nBuilt upon the msgpack formats fixarray, array 16, array 32.\n\nDefaults\n\nVectorFormat is the default format for subtypes of Tuple and AbstractVector. Use\n\nformat(::Type{T}) = VectorFormat()\n\nor\n\n@pack T in VectorFormat\n\nto make VectorFormat the default format for type T. If T is abstract, use {<: T} to cover all subtypes.\n\nPacking\n\nTo support packing values of type T in VectorFormat, implement\n\ndestruct(val::T, ::VectorFormat)::R\n\nwhere the returned value ret::R must implement Base.length(ret) (number of entries) and must be iterable. The formats of the entries of val are determined via valueformat, where state is the linear index.\n\nUnpacking\n\nTo support unpacking values of type T packed in VectorFormat,  implement\n\nconstruct(::Type{T}, values::Generator{T}, ::VectorFormat)::T\n\nor make sure that the constructor T(values::Generator{T}) is defined (see Generator). The respective types and formats of the entries of values are determined via valuetype and valueformat, where state is the linear index.\n\nwarning: Warning\nDuring construction, all entries of the generator values have to be iterated over. Since Generator{T} wraps a lazy map that reads from the IO source to be unpacked, not conducting the iteration before the next object is processed will interfere with unpacking of subsequent values. For the same reason, you should not store the object values and access it at a later time.\n\n\n\n\n\n","category":"type"},{"location":"formats/#StructPack.ArrayFormat","page":"Formats","title":"StructPack.ArrayFormat","text":"Format for arrays that remembers the array size.\n\nBuilt upon VectorFormat.\n\nDefaults\n\nArrayFormat is the default format for AbstractArray. Use\n\nformat(::Type{T}) = ArrayFormat()\n\nor\n\n@pack T in ArrayFormat\n\nto make ArrayFormat the default format for type T. If T is abstract, use {<: T} to cover all subtypes.\n\nPacking\n\nTo support packing values of type T in ArrayFormat, implement\n\ndestruct(val::T, ::ArrayFormat)::R\n\nwhere the returned value ret::R must define size and must be packable in VectorFormat.\n\nUnpacking\n\nTo support unpacking values of type T packed in ArrayFormat, implement\n\nconstruct(::Type{T}, ::ArrayValue{Generator{T}}, ::ArrayFormat)::T\n\nor make sure that the constructor T(val::ArrayValue{Generator{T}}) is defined (see ArrayValue and Generator).\n\n\n\n\n\n","category":"type"},{"location":"formats/#StructPack.BinVectorFormat","page":"Formats","title":"StructPack.BinVectorFormat","text":"Pack vectors in binary format.  \n\nBuilt upon BinaryFormat.\n\nDefaults\n\nBinVectorFormat is the default format for BitVector. Use\n\nformat(::Type{T}) = BinVectorFormat()\n\nor\n\n@pack T in BinVectorFormat\n\nto make BinVectorFormat the default format for type T. If T is abstract, use {<: T} to cover all subtypes.\n\nPacking\n\nTo support packing values of type T in BinVectorFormat, implement\n\ndestruct(val::T, ::BinVectorFormat)::R\n\nwhere the returned value ret::R must be packable in BinaryFormat.\n\nUnpacking\n\nTo support unpacking values of type T packed in BinVectorFormat, implement\n\nconstruct(::Type{T}, ::Vector{UInt8}, ::BinVectorFormat)::T\n\nor make sure that the constructor T(bytes::Vector{UInt8}) is defined.\n\n\n\n\n\n","category":"type"},{"location":"formats/#StructPack.BinArrayFormat","page":"Formats","title":"StructPack.BinArrayFormat","text":"Pack arrays in binary format.  \n\nBuilt upon BinVectorFormat.\n\nDefaults\n\nBinArrayFormat is the default format for BitArray{N} for N > 1. Use\n\nformat(::Type{T}) = BinArrayFormat()\n\nor\n\n@pack T in BinArrayFormat\n\nto make BinVectorFormat the default format for type T. If T is abstract, use {<: T} to cover all subtypes.\n\nPacking\n\nTo support packing values of type T in BinArrayFormat, implement\n\ndestruct(val::T, ::BinArrayFormat)::R\n\nwhere the returned value ret::R must define Base.size and must be packable in BinaryFormat.\n\nUnpacking\n\nTo support unpacking values of type T packed in BinArrayFormat, implement\n\nconstruct(::Type{T}, ::BinArrayValue{Vector{UInt8}}, ::BinArrayFormat)::T\n\nor make sure that the constructor T(val::BinArrayValue{Vector{UInt8}}) is defined (see [BinArrayValue(@ref)]).\n\n\n\n\n\n","category":"type"},{"location":"formats/#StructPack.DynamicVectorFormat","page":"Formats","title":"StructPack.DynamicVectorFormat","text":"Modification of VectorFormat.\n\nDuring unpacking, the types and formats of future entries may depend on past entries via overloading iterstate.\n\ninfo: Info\nDynamicVectorFormat is currently slower than VectorFormat, even if iterstate just enumerates indices. In principle, however, the compiler should have all information neccessary to optimize DynamicVectorFormat in this case and bring the performance on par. In the future, we might thus deprecate DynamicVectorFormat and absorb its functionality into VectorFormat.\n\n\n\n\n\n","category":"type"},{"location":"formats/#Map-formats","page":"Formats","title":"Map formats","text":"","category":"section"},{"location":"formats/","page":"Formats","title":"Formats","text":"Besides MapFormat, which directly mirrors the msgpack map format, StructPack.jl also provides specialized map implementations for structures.","category":"page"},{"location":"formats/","page":"Formats","title":"Formats","text":"AbstractMapFormat\nMapFormat\nDynamicMapFormat\nAbstractStructFormat\nStructFormat\nUnorderedStructFormat\nFlexibleStructFormat","category":"page"},{"location":"formats/#StructPack.AbstractMapFormat","page":"Formats","title":"StructPack.AbstractMapFormat","text":"Umbrella type for MapFormat, DynamicMapFormat, and AbstractStructFormat.\n\n\n\n\n\n","category":"type"},{"location":"formats/#StructPack.MapFormat","page":"Formats","title":"StructPack.MapFormat","text":"Core format for packing map / dictionary values.\n\nBuilt upon the msgpack formats fixmap, map 16, map 32.\n\nDefaults\n\nMapFormat is the default format for subtypes of NamedTuple and Dict. Use\n\nformat(::Type{T}) = MapFormat()\n\nor\n\n@pack T in MapFormat\n\nto make MapFormat the default format for type T. If T is abstract, use {<: T} to cover all subtypes.\n\nPacking\n\nTo support packing values of type T in MapFormat, implement\n\ndestruct(val::T, ::MapFormat)::R\n\nwhere the returned value ret::R must implement Base.length(ret) (number of entries) and must be iterable with key-value pairs as entries. The key / value formats of the entries of val are determined via keyformat and valueformat, where state is the linear index.\n\nUnpacking\n\nTo support unpacking values of type T packed in MapFormat,  implement\n\nconstruct(::Type{T}, pairs::Generator{T}, ::MapFormat)::T\n\nor make sure that the constructor T(pairs::Generator{T}) is defined (see Generator), where pairs will contain key-value pairs as entries. The respective types and formats of the keys and values are determined during unpacking via keytype, valuetype, keyformat and valueformat, where state is the linear index.\n\nwarning: Warning\nDuring construction, all entries of the generator pairs have to be iterated over. Since Generator{T} wraps a lazy map that reads from the IO source to be unpacked, not conducting the iteration before the next object is processed will interfere with unpacking of subsequent values. For the same reason, you should not store the object pairs and access it at a later time.\n\n\n\n\n\n","category":"type"},{"location":"formats/#StructPack.DynamicMapFormat","page":"Formats","title":"StructPack.DynamicMapFormat","text":"Modification of MapFormat.\n\nDuring unpacking, the types and formats of future entries may depend on past entries via overloading iterstate.\n\ninfo: Info\nDynamicMapFormat is currently slower than MapFormat, even if iterstate just enumerates indices. In principle, however, the compiler should have all information neccessary to optimize DynamicMapFormat in this case and bring the performance on par. In the future, we might thus deprecate DynamicMapFormat and absorb its functionality into MapFormat.\n\n\n\n\n\n","category":"type"},{"location":"formats/#StructPack.AbstractStructFormat","page":"Formats","title":"StructPack.AbstractStructFormat","text":"Umbrella type for StructFormat, UnorderedStructFormat, and FlexibleStructFormat.\n\n\n\n\n\n","category":"type"},{"location":"formats/#StructPack.StructFormat","page":"Formats","title":"StructPack.StructFormat","text":"Format for packing structures.\n\nBuilt upon the msgpack formats fixmap, map 16, map 32.\n\nDefaults\n\nStructFormat is not used as default for any type. However, it should be the first candidate when you want to pack custom structs. Use\n\nformat(::Type{T}) = StructFormat()\n\nor\n\n@pack T in StructFormat\n\nto make StructFormat the default format for type T. If T is abstract, use {<: T} to cover all subtypes.\n\nPacking\n\nTo support packing values of type T in StructFormat, implement\n\ndestruct(val::T, ::MapFormat)::R\n\nwhere the returned value ret::R must implement Base.length(ret) (number of entries) and must be iterable with key-value pairs as entries.\n\nIn contrast to MapFormat, the keys are always stored in StringFormat and the value formats are determined via fieldformats, which should return a tuple of formats for the value-entries of the struct.\n\nUnpacking\n\nTo support unpacking values of type T packed in StructFormat,  implement\n\nconstruct(::Type{T}, pairs::Generator{T}, ::StructFormat)::T\n\nor make sure that the constructor T(values...) is defined, where values contains the value-entries of pairs.\n\nThe respective types and formats of the values are determined during unpacking via fieldtypes and fieldformats, which should return tuples of types and formats. Additionally, fieldnames is queried to make sure the keys encountered during unpacking are consistent with T.\n\nnote: StructFormat vs. MapFormat\nBoth StructFormat and MapFormat can be used to pack custom structs. They perform comparably.MapFormat is more flexible and can handle keys that are not symbols. In contrast, StructFormat requires static fieldtype, fieldname, and fieldformat information.\nHowever, MapFormat will not counter-check key values during unpacking and can thus easily lead to corrupted data if applied on external msgpack binaries.\n\n\n\n\n\n","category":"type"},{"location":"formats/#StructPack.UnorderedStructFormat","page":"Formats","title":"StructPack.UnorderedStructFormat","text":"Modification of StructFormat.\n\nThis map-based format automatically sorts entries according to fieldnames during unpacking.\n\nWhile the unpacking performance is deteriorated compared to StructFormat, this format makes it possible to load msgpack binaries where the order of map-entries cannot be guaranteed.\n\nBy default, the constructor T(values...) is used when unpacking a type T in UnorderedStructFormat, where values denotes the value-entries unpacked from the msgpack map. To use a keyword-argument based constructor, simply define\n\nconstruct(::Type{T}, pairs, ::UnorderedStructFormat) = T(; pairs...)\n\n\n\n\n\n","category":"type"},{"location":"formats/#StructPack.FlexibleStructFormat","page":"Formats","title":"StructPack.FlexibleStructFormat","text":"Modification of StructFormat.\n\nWhen unpacking a value in map format, this format ignores superfluous fields and supports reading only a subset of the fields of a struct.\n\nBy default, the keyword argument based constructor T(; pairs...) is used when unpacking a type T in FlexibleStructFormat, where pairs denotes the entries unpacked from the msgpack map.\n\n\n\n\n\n","category":"type"},{"location":"formats/#Type-formats","page":"Formats","title":"Type formats","text":"","category":"section"},{"location":"formats/","page":"Formats","title":"Formats","text":"TypeFormat\nTypedFormat","category":"page"},{"location":"formats/#StructPack.TypeFormat","page":"Formats","title":"StructPack.TypeFormat","text":"Format that is used for packing types.\n\nIn order to pack and unpack a type T::Type in TypeFormat, make sure that t = StructPack.TypeValue(T) works and that StructPack.composetype(t) successfully reconstructs T.\n\nIf T has type parameters, their serialization can be influenced via the functions typeparamtypes and typeparamformats.\n\nBy default, all type parameters are packed / unpacked in TypedFormat.\n\n\n\n\n\n","category":"type"},{"location":"formats/#StructPack.TypedFormat","page":"Formats","title":"StructPack.TypedFormat","text":"Wrapper format for storing the value and type of an object.\n\nIf a value val::T can be packed in the format F<:Format and its type T can be packed in TypeFormat, then packing val in TypedFormat{F} enables unpacking via unpack(io, TypedFormat{F}()), i.e., without knowledge of T.\n\n\n\n\n\n","category":"type"},{"location":"formats/#Special-formats","page":"Formats","title":"Special formats","text":"","category":"section"},{"location":"formats/","page":"Formats","title":"Formats","text":"DefaultFormat\nAnyFormat\nSetContextFormat","category":"page"},{"location":"formats/#StructPack.DefaultFormat","page":"Formats","title":"StructPack.DefaultFormat","text":"Special format that serves as lazy placeholder for format(T) in situations where the type T is not yet known.\n\nwarning: Warning\nNever define format(T) for a type T in terms of DefaultFormat. This will lead to indefinite recursion.\n\n\n\n\n\n","category":"type"},{"location":"formats/#StructPack.AnyFormat","page":"Formats","title":"StructPack.AnyFormat","text":"Convenience format to unpack generic msgpack values.\n\nNote that custom contexts (see Context) are ignored by AnyFormat.\n\nnote: Note\nThe msgpack timestamp format is currently not supported by AnyFormat.\n\n\n\n\n\n","category":"type"},{"location":"formats/#StructPack.SetContextFormat","page":"Formats","title":"StructPack.SetContextFormat","text":"Special format that overrides the current context.\n\nIn particular, packing (or similarly unpacking) via\n\npack(val, SetContextFormat{C, F}(), C2())\n\nis equivalent to\n\npack(val, F(), C())\n\nwhere the original context C2 <: Context is ignored.\n\nThis format is, for example, useful in combination with fieldformats, to enforce that different fields of a struct can be packed / unpacked with different contexts.\n\n\n\n\n\n","category":"type"},{"location":"usage/","page":"Usage","title":"Usage","text":"CurrentModule = StructPack","category":"page"},{"location":"usage/#Usage","page":"Usage","title":"Usage","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"In order to serialize or deserialize a value of type T via StructPack.jl, a format must be specified. A format is a singleton subtype of Format. This can either happen by explicitly providing it when calling pack and unpack, or by setting a default format via overloading format. Different formats might have different requirements for T.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"A number of basic julia types already have a default format associated to them and can be packed / unpacked without further instructions.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"using StructPack\n\nstr = \"This is a string\" # StringFormat by default\ntup = (\"tuple\", 5, false) # VectorFormat by default\nntup = (a = str, b = tup) # StructFormat by default\n\nbytes = pack(ntup)\nunpack(bytes, typeof(ntup))\n\n# or alternatively \n\nio = IOBuffer()\npack(io, ntup)\nseekstart(io)\nunpack(io, typeof(ntup))","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"When using StructPack is issued, the functions pack and unpack, the macro @pack, and a set of built-in formats is exported.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"The type information passed to unpack is needed, since no such information is stored in bytes. If it is left out, Pack.unpack(bytes) tries to load bytes as generic msgpack object and returns a dictionary (since ntup is stored in the msgpack map format). We will later see how type information can be stored as well, enabling generic unpacking.","category":"page"},{"location":"usage/#Custom-packing","page":"Usage","title":"Custom packing","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"StructPack.jl gives you several out-of-the-box options how to serialize a custom structure.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"struct MyStruct\n  a::Float64\n  b::String\nend\n\nStructPack.format(::Type{MyStruct}) = MapFormat()\n# or\nStructPack.format(::Type{MyStruct}) = StructFormat()\n# or\nStructPack.format(::Type{MyStruct}) = UnorderedStructFormat()\n# or\nStructPack.format(::Type{MyStruct}) = VectorFormat()\n\nbytes = pack(MyStruct(0., \"a string\"))","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"In the first three cases, the binary bytes will coincide. The difference lies in the unpacking: MapFormat will (by default) not check if the keys in bytes confirm to :a and :b. StructFormat, on the other hand, will perform such a consistency check. UnorderedStructFormat will also perform such a check. It is slower but can unpack msgpack binaries where the order of the entries are altered.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"bytes1 = pack((a = 0., b = \"a string\")) # coincides with bytes\nbytes2 = pack((ab = 0., ba = \"a string\"))\nbytes3 = pack((b = 0., a = \"a string\"))\n\n# All of these will work as intended\nunpack(bytes1, MyStruct, MapFormat())\nunpack(bytes1, MyStruct, StructFormat())\nunpack(bytes1, MyStruct, UnorderedStructFormat())\n\n# This will fail for StructFormat and UnorderedStructFormat\nunpack(bytes2, MyStruct, MapFormat())\n\n# This will not work as intended for MapFormat and will fail for StructFormat\nunpack(bytes3, MyStruct, UnorderedStructFormat())","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"If you choose VectorFormat, the keys :a and :b are not stored at all in bytes. Unpacking then only relies on the order of the arguments. In particular, pack(MyStruct(0., \"b\"), VectorFormat()) == pack([0., \"b\"]).","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"To make the specification of default formats more convenient, StructPack.jl also provides the macro @pack.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"@pack MyStruct in StructFormat\n# is equivalent to\nStructPack.format(::Type{MyStruct}) = StructFormat()","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"This macro has additional benefits: If you do not want to store all fields of MyStruct, or use a specific constructor when unpacking, you can easily inform @pack in combination with StructFormat or UnorderedStructFormat.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"# Special constructor we want to use during unpacking\nMyStruct(a; b) = MyStruct(a, b)\n@pack MyStruct in StructFormat (a; b)\n\n# or\n\n# The constructor has a custom name\ncreate_mystruct(; a, b) = MyStruct(a, b)\n@pack MyStruct in StructFormat create_mystruct(; a, b)\n\n# or\n\n# We only want to store the field a\nMyStruct(a) = MyStruct(a, \"b is always the same\")\n@pack MyStruct in StructFormat (a,)","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"With a bit of additional code we have even more flexibility. For example, after we have decided to store only the field MyStruct.a::Float64 anyway, we could just directly use FloatFormat.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"StructPack.format(::Type{MyStruct}) = FloatFormat()\nStructPack.destruct(val::MyStruct, ::FloatFormat) = val.a\nStructPack.construct(::Type{MyStruct}, a, ::FloatFormat) = MyStruct(a)","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"The functions destruct and construct are called before packing and after unpacking. Consult the docstrings of the various in-built formats to learn about their respective requirements for these functions.","category":"page"},{"location":"usage/#Parents-matter","page":"Usage","title":"Parents matter","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"StructPack.jl strives to be flexible when handling custom structs. In particular, it disagrees that a given value val::T should always be serialized in the same way, independent of the circumstances.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"There are two primary mechanism to enforce context-dependent customizations when packing and unpacking a value: Via its parent structure, or via Context objects.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Here is a simple example where a field (the child) of a struct (the parent) receives a non-default format.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"struct MyOtherStruct\n  a::String           # Default format is StringFormat\n  b::Vector{Float32}  # Default format is VectorFormat\nend\n\n# We decide that MyStruct.b should rather be stored as binary vector\n@pack MyOtherStruct in StructFormat [b in BinVectorFormat]","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"The auxiliary format BinVectorFormat causes that MyOtherStruct.b will be stored in the msgpack binary format. Without further effort, this only works for types Vector{F} where isbitstype(F) is true.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Note that this call to @pack can be combined with the specification of a particular constructor (as above).","category":"page"},{"location":"usage/#Context-matters","page":"Usage","title":"Context matters","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"Another way to modify the format of a given value val::T are context objects, realized as singleton subtypes of Context. Context objects are particularly useful if you desired to change how val::T is serialized throughout (a part of) your code, but are reluctant to modify the global behavior for all values of type T. For example, T might belong to a third party package and you do not want to mess with its packing defaults.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"struct MyContext <: StructPack.Context end\n\n# Under MyContext, MyOtherStruct.b is packed in ArrayFormat\n# and the field order does not matter for unpacking\n@pack MyContext MyOtherStruct in UnorderedStructFormat [b in ArrayFormat]\n\nvalue = MyOtherStruct(\"Is my data stored in binary?\", rand(Float32, 10))\nbytes1 = pack(value, MyContext()) # ArrayFormat is used for field b\nbytes2 = pack(value)              # BinVectorFormat is used for field b\n\n# Unpacking must also get informed about the context\nunpack(bytes1, MyOtherStruct, MyContext())\nunpack(bytes2, MyOtherStruct)","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Here you have encountered ArrayFormat. This auxiliary format is able to store and recover (multidimensional) arrays by also storing the array size (see also BinArrayFormat).","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"For convenience, it is also possible to temporarily alter the default context for a block of code via the scoped value context.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"using Base.ScopedValues\n\nwith(StructPack.context=>MyContext()) do\n  bytes = pack(value) # ArrayFormat is used\n  unpack(bytes, MyOtherStruct)\nend","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Furthermore, you can dynamically switch the active context during packing / unpacking via the special format SetContextFormat. Consider the following piece of code.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"struct ParentStruct\n  a::MyOtherStruct # Want to use the default context for this one\n  b::MyOtherStruct # Want to use MyContext for this one\nend\n\n@pack ParentStruct in StructFormat [b in SetContextFormat{MyContext}]\n\n# or, if we also want to change the format for the field b from unordered to ordered\n\n@pack ParentStruct in StructFormat [b in SetContextFormat{MyContext, StructFormat}]","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Since SetContextFormat is a bit unwieldy, the @pack macro accepts the abbreviation F[C] for SetContextFormat{C, F}. Thus, the two packing lines in the code above are equvivalent to","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"@pack ParentStruct in StructFormat [b in DefaultFormat[MyContext]]\n@pack ParentStruct in StructFormat [b in StructFormat[MyContext]]","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Contexts can reach into and alter nearly each aspect of the serialization, as they penetrate into each relevant packing related call (pack, unpack, format, fieldformats, ...). In general, to add a custom rule for your context, you can just overload the respective function with a trailing argument for the context. For example, the following two lines are equivalent:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"@pack MyContext MyOtherStruct in StructFormat\nStructPack.format(::Type{MyOtherStruct}, ::MyContext) = StructFormat()","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Below, we demonstrate in more detail which functions are overloaded when employing the @pack macro. ","category":"page"},{"location":"usage/#Contexts:-Case-study","page":"Usage","title":"Contexts: Case study","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"As mentioned above, contexts are useful to prevent the following uglyness: You want to serialize a type B.A from a package B in another way than the maintainers of package C want to serialize B.A. In general, the rule is to never set global default formats for types that you do not own. Always use the parent-mechanism or a dedicated context for such types.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"However, the main reason why I have included contexts into StructPack.jl is a different one. Imagine you want to save and load project files that capture some aspect of a program you are developing (think of a save state in a game). The first version, v1, might correspond directly to your project structure.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"struct Project\n  a::String\n  b::Int\n  c::Float64\nend\n\n@pack Project in StructFormat\n\nsaveproject(path, p::Project) = open(path, \"w\") do io\n  pack(io, p)\nend\n\nloadproject(path) = open(path, \"r\") do io\n  unpack(io, Project)\nend\n\nsaveproject(\"myproject.pack\", Project(\"test\", 5, 0.))","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Great! For version v2, however, you add a new feature and your project structure changes. It now looks like this:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"struct Project\n  c::Float64\n  b::Tuple{Int, Int}\n  a::String\n  d::Bool\nend","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"What to do with your now defunct project file myproject.pack? Of course, you could make up a mock structure ProjectV1 that mirrors the old format and provides a conversion function. Or you could just unpack myproject.pack as a dictionary and convert it back to a struct. ","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"In complicated settings, however, both of these options are cumbersome. This is especially true if several structs (that may be children of Project) change, maybe only slightly. You then either have to keep slight variations of countles struct copies around, or have to plow your way through nested dicts. The same horror continues with the next version v3.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Here, contexts in concert with the @pack macro become very useful.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"struct CompatV1V2 <: StructPack.Context end\n\nv1_to_v2(a, b, c) = Project(c, (b, b), a, false)\n\n@pack CompatV1V2 Project in StructFormat v1_to_v2(a, b::Int, c)\n\nloadproject_v2(path) = open(path, \"r\") do io\n  unpack(io, Project, CompatV1V2())\nend\n\np = loadproject_v2(\"myproject.pack\")","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Note that the context CompatV1V2 is \"ill-defined\", in that you cannot pack and consequtively unpack an object of type Project in it (since we had to lie about the type of Project.b, which is ignored by packing but respected by unpacking). However, we only need it for loading anway.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"The value of this approach might not be too apparent in this simple example, but its composability pays when Project contains nested custom structs. In fact, we could even handle renamed fields quite principled by specializing StructPack.fieldnames given the context CompatV1V2.","category":"page"},{"location":"usage/#A-world-without-macros","page":"Usage","title":"A world without macros","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"How does the @pack macro work? Under the hood, it just overloads relevant packing functions. This means that every effect achievable via @pack can quite easily be achieved without macro as well, albeit at the cost of more code.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"For example, the macro call","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"@pack C A in StructFormat (a, c::Tc; b) [b in Fb]","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"is essentially expanded to","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"StructPack.format(::Type{A}, ::C) = StructFormat()\n\nStructPack.destruct(val::A, ::C) = (val.a, val.c, val.b)\n\nfunction StructPack.construct(::Type{A}, pairs, ::C)\n  args = (pairs[1][2], pairs[2][2])\n  kwargs = (pairs[3],)\n  A(args...; kwargs...)\nend\n\nStructPack.fieldnames(::Type{A}, ::C) = (:a, :c, :b)\n\nfunction StructPack.fieltypes(::Type{A}, ::C)\n  # This is actually solved via a generated function, so the calls to fieldtype\n  # take place before compile time\n  (fieldtype(A, :a), Tc, fieldtype(A, :b))\nend\n\nfunction StructPack.fieldformats(::Type{A}, ::C)\n  (DefaultFormat(), DefaultFormat(), Fb())\nend","category":"page"},{"location":"usage/#Unpacking-the-abstract","page":"Usage","title":"Unpacking the abstract","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"Until now, we have only considered unpacking when we knew the concrete type of our object beforehand. This implies heavy limitations. For example, what would we do in the following situation?","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"abstract type Vehicle end\n\nstruct Boat <: Vehicle\n  a::Int\nend\n\nstruct Train <: Vehicle\n  b::Float64\nend\n\nstruct Ticket\n  price::Float64\n  vehicle::Vehicle\nend","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Here we have to call unpack(..., Vehicle) at some point, which clearly does not tell us about the underlying msgpack layout beforehand. To resolve this issue, it is necessary that some type information is stored alongside the value.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"In StructPack.jl, this problem is solved via the special auxiliary format TypedFormat.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"@pack {<: Vehicle} in TypedFormat{StructFormat}\n\nbytes = pack(Boat(42)) # This will be a lot of bytes...\nunpack(bytes, Vehicle) # ... but this will work!","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Now, packing a value of type Vehicle will actually store a msgpack map with the two keys :type and :value, the first of which contains type information sufficient to reconstruct the concrete type. The value stored behind the key :value will be formatted in StructFormat.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"This is very convenient. However, you should realize that we also approach potential complications.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"The performance of packing and unpacking suffers notably when using TypedFormat. This means that you should avoid storing lots and lots of values in this format. \nPacking and unpacking in TypedFormat becomes more complicated when the abstract type (Vehicle in the example above) has type parameters, i.e., if we had defined Vehicle{A, B}. In this case we also have to serialize A and B when serializing the type.  Since it seems to be impossible to automatically extract necessary information about A and B (for example, is A a type or a symbol?), this information has to be supplied explicitly via typeparamtypes and typeparamformats.","category":"page"},{"location":"usage/#Generic-unpacking","page":"Usage","title":"Generic unpacking","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"If you want to unpack a generic msgpack binary, you can do so by just leaving out the target type during unpacking.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"val = (:a, 5, (b = 7, c = \"c\"))\nbytes = pack(val)\n\n # Will return an array, where the last (third) entry is a dict\nunpack(bytes)","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Under the hood, generic unpacking is realized via the special AnyFormat. This format currently uses the julia Array type for msgpack vectors and Dict for msgpack maps. As a consequence, the ordering of maps is lost and duplicated keys will lead to data loss.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Any valid msgpack value should be correctly unpackable this way. Otherwise it is considered a bug of StructPack.jl.","category":"page"},{"location":"context/","page":"Context","title":"Context","text":"CurrentModule = StructPack","category":"page"},{"location":"context/#Context","page":"Context","title":"Context","text":"","category":"section"},{"location":"context/","page":"Context","title":"Context","text":"Context\nDefaultContext","category":"page"},{"location":"context/#StructPack.Context","page":"Context","title":"StructPack.Context","text":"Abstract serialization context.\n\nA context can be introduced to temporarily enforce custom behavior when packing and unpacking values.\n\nIn particular, a context can influence which formats are assigned to types (via format) or to fields of a struct (via valueformat). It can also influence how objects are processed before packing and after unpacking (via destruct and construct).\n\n\n\n\n\n","category":"type"},{"location":"context/#StructPack.DefaultContext","page":"Context","title":"StructPack.DefaultContext","text":"Context that directs packing / unpacking towards fallback implementations.\n\nThis is an auxiliary type and should not come into contact with users of the package.\n\nwarning: Warning\nDo not dispatch on ::DefaultContext to provide global defaults. Always use Context-free methods for this purpose. For example, use format(::Type{MyType}) = ... instead of format(::Type{MyType}, ::DefaultContext) = ... to set a default format for MyType.\n\n\n\n\n\n","category":"type"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"CurrentModule = StructPack","category":"page"},{"location":"reference/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"reference/#Main-API","page":"API Reference","title":"Main API","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"format\npack\nunpack\nconstruct\ndestruct","category":"page"},{"location":"reference/#StructPack.format","page":"API Reference","title":"StructPack.format","text":"format(T::Type [, ctx::Context])::Format\nformat(::T [, ctx::Context])::Format\n\nReturn the format associated to type T under ctx.\n\nThe context-free version of this method must be implemented in order for pack(io, value::T) and unpack(io, T) to work. It is used as fallback for all contexts.\n\nSee also Format and DefaultFormat.\n\n\n\n\n\n","category":"function"},{"location":"reference/#StructPack.pack","page":"API Reference","title":"StructPack.pack","text":"pack(value, [, ctx::Context])::Vector{UInt8}\npack(value, [, fmt::Format, ctx::Context])::Vector{UInt8}\npack(io::IO, args...)::Nothing\n\nCreate a binary msgpack representation of value according to the given format fmt. If a stream io is passed, the representation is written into it.\n\nIf no format is provided, it is derived from the type of value via format(typeof(value), ctx). The context defaults to the value of context, which is a scoped value in julia 1.11 or newer and a reference else.\n\nIf both a format and a context is provided, fmt is used for packing value while ctx is passed along to deeper packing related calls.\n\n\n\n\n\n","category":"function"},{"location":"reference/#StructPack.unpack","page":"API Reference","title":"StructPack.unpack","text":"unpack(bytes::Vector{UInt8}, T::Type [, ctx::Context])::T\nunpack(bytes::Vector{UInt8}, T::Type [, fmt::Format, ctx:::Context])::T\nunpack(io::IO, T::Type, args...)::T\n\nUnpack a binary msgpack representation of a value of type T in format fmt from a byte vector bytes or a stream io. The returned value is guaranteed to be of type T.\n\nIf no format is provided, it is derived from T via format(T, ctx). The context ctx defaults to context.\n\n\n\n\n\nunpack(bytes::Vector{UInt8})::Any\nunpack(io::IO)::Any\n\nUnpack a binary msgpack value via the special format AnyFormat. The returned value can be of any type.\n\n\n\n\n\n","category":"function"},{"location":"reference/#StructPack.construct","page":"API Reference","title":"StructPack.construct","text":"construct(T::Type, val, fmt::Format [, ctx::Context])::T\n\nPostprocess a value val unpacked according to fmt and return an object of type T. The type of val depends on the format fmt that was used for unpacking.\n\nDefaults to T(val) but can be overwritten for any combination of T, fmt, and ctx.\n\n\n\n\n\n","category":"function"},{"location":"reference/#StructPack.destruct","page":"API Reference","title":"StructPack.destruct","text":"destruct(val::T, fmt::Format [, ctx::Context])\n\nPreprocess a value val to prepare packing it in the format fmt.\n\nDefaults to val but can be overwritten for any combination of T, fmt, and ctx.\n\nEach format has specific requirements regarding the output of this method.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Keys-and-values","page":"API Reference","title":"Keys and values","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"keytype\nkeyformat\nvaluetype\nvalueformat\niterstate","category":"page"},{"location":"reference/#StructPack.keytype","page":"API Reference","title":"StructPack.keytype","text":"keytype(T::Type, state, fmt::Format [, ctx::Context])::Type\n\nReturn the type of the key at iteration state state when saving the entries of T in format fmt.\n\nThis method is called when unpacking values in AbstractMapFormat.\n\n\n\n\n\n","category":"function"},{"location":"reference/#StructPack.keyformat","page":"API Reference","title":"StructPack.keyformat","text":"keyformat(T::Type, state, fmt::Format [, ctx::Context])::Format\n\nReturn the format of the key at iteration state state when saving the entries of T in format fmt.\n\nThis method is called when packing or unpacking values in AbstractMapFormat.\n\n\n\n\n\n","category":"function"},{"location":"reference/#StructPack.valuetype","page":"API Reference","title":"StructPack.valuetype","text":"valuetype(T::Type, fmt::Format, state [, ctx::Context])::Type\n\nReturn the type of the value at iteration state state when saving the entries of T in format fmt.\n\nThis method is used when unpacking values in AbstractVectorFormat and AbstractMapFormat.\n\n\n\n\n\n","category":"function"},{"location":"reference/#StructPack.valueformat","page":"API Reference","title":"StructPack.valueformat","text":"valueformat(T::Type, state, fmt::Format [, ctx::Context])::Format\n\nReturn the format of the value at iteration state state when saving the entries of T in format fmt.\n\nThis method is used when packing or unpacking values in AbstractVectorFormat and AbstractMapFormat.\n\n\n\n\n\n","category":"function"},{"location":"reference/#StructPack.iterstate","page":"API Reference","title":"StructPack.iterstate","text":"iterstate(T::Type, fmt::Format [, ctx::Context])\n\nInitialize a state object that is repeatedly updated while iterating over the entries of values of type T when packing and unpacking in format fmt.\n\nBy default, the initial state is 1 and gets replaced by state + 1 in subsequent updates.\n\nThis function is only relevant for formats that dynamically make use of the methods keytype, keyformat, valuetype, or valueformat, like DynamicVectorFormat and DynamicMapFormat.\n\n\n\n\n\niterstate(T::Type, state, entry, fmt::Format [, ctx::Context])\n\nReturn an update of the state object state when T is packed or unpacked in the format fmt.\n\nThe argument entry signifies the entry packed / unpacked in the last iteration and can be used to inform the next iteration state. It will be of type valuetype(T, fmt, state, ctx) in case of DynamicVectorFormat and similarly a key-value pair with types determined by keytype and valuetype in case of DynamicMapFormat.\n\nThis approach enables 'dynamic' unpacking where the type / format of an entry depends on the values unpacked previously. The format TypedFormat exploits this pattern.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Struct-fields","page":"API Reference","title":"Struct fields","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"fieldformats\nfieldtypes\nfieldnames","category":"page"},{"location":"reference/#StructPack.fieldformats","page":"API Reference","title":"StructPack.fieldformats","text":"fieldformats(T::Type [, ctx::Context])\n\nReturn the field types of T when packing / unpacking in AbstractStructFormat under ctx.\n\n\n\n\n\n","category":"function"},{"location":"reference/#StructPack.fieldtypes","page":"API Reference","title":"StructPack.fieldtypes","text":"fieldtypes(T::Type [, ctx::Context])\n\nReturn the field types of T when packing / unpacking in AbstractStructFormat under ctx.\n\nDefaults to Base.fieldtypes(T).\n\n\n\n\n\n","category":"function"},{"location":"reference/#StructPack.fieldnames","page":"API Reference","title":"StructPack.fieldnames","text":"fieldnames(T::Type [, ctx::Context])\n\nReturn the field names of T when packing / unpacking in AbstractStructFormat under ctx.\n\nDefaults to Base.fieldnames(T).\n\n\n\n\n\n","category":"function"},{"location":"reference/#Auxiliary-types","page":"API Reference","title":"Auxiliary types","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Generator\nArrayValue\nBinArrayValue\nTypeValue\nTypedValue","category":"page"},{"location":"reference/#StructPack.Generator","page":"API Reference","title":"StructPack.Generator","text":"Auxiliary object for unpacking sequential values.\n\nImplements the Base iterator interface and can for most purposes be treated like a Base.Generator. Compared to the latter, it is equipped with additional element type information via its first type parameter T.\n\nIn particular, when unpacking a value of type Generator{T} in VectorFormat or MapFormat, the methods valuetype, valueformat, keytype, and keyformat are called with type argument T to determine how elements are unpacked.\n\n\n\n\n\n","category":"type"},{"location":"reference/#StructPack.ArrayValue","page":"API Reference","title":"StructPack.ArrayValue","text":"Wrapper struct employed when unpacking a value in ArrayFormat.\n\nContains the fields size and data, the latter of which is usually a Generator after reconstruction via unpack.\n\n\n\n\n\n","category":"type"},{"location":"reference/#StructPack.BinArrayValue","page":"API Reference","title":"StructPack.BinArrayValue","text":"Wrapper object for unpacking values in BinArrayFormat.\n\nContains the fields size and data, the latter of which is a Vector{UInt8} after reconstruction via unpack.\n\n\n\n\n\n","category":"type"},{"location":"reference/#StructPack.TypeValue","page":"API Reference","title":"StructPack.TypeValue","text":"Auxiliary structure that expresses a type in a format friendly to serialization.\n\n\n\n\n\n","category":"type"},{"location":"reference/#StructPack.TypedValue","page":"API Reference","title":"StructPack.TypedValue","text":"Auxiliary structure that expresses a value and its type in a format friendly to serialization.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Typed-format","page":"API Reference","title":"Typed format","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"typeparamtypes\ntypeparamformats","category":"page"},{"location":"reference/#StructPack.typeparamtypes","page":"API Reference","title":"StructPack.typeparamtypes","text":"typeparamtypes(T::Type [, ctx::Context])\n\nReturn the types of the type parameters of T when packing / unpacking under ctx.\n\nnote: Note\nIf T has type parameters, this method must be implemented for packing / unpacking types via TypeFormat and TypedFormat.\n\n\n\n\n\n","category":"function"},{"location":"reference/#StructPack.typeparamformats","page":"API Reference","title":"StructPack.typeparamformats","text":"typeparamformats(T::Type [, ctx::Context])\n\nReturn the formats of the type parameters of T when packing / unpacking under ctx.\n\nDefaults to DefaultFormat() for each type parameter.\n\nThis method is consulted when packing / unpacking types via TypeFormat and TypedFormat.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Scoped-values","page":"API Reference","title":"Scoped values","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"context","category":"page"},{"location":"reference/#StructPack.context","page":"API Reference","title":"StructPack.context","text":"Scoped value that captures the active context.\n\nTo pack / unpack in a given context ctx::Context, you can use this pattern:\n\nusing Base.ScopedValues\n\nwith(StructPack.context => ctx) do\n  # Do your packing / unpacking without passing ctx explicitly\n  # ...\nend\n\ninfo: Info\nPrior to julia 1.11, this constant was a global reference.\n\n\n\n\n\n","category":"constant"},{"location":"reference/#Auxiliary-functions","page":"API Reference","title":"Auxiliary functions","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"skip\nstep","category":"page"},{"location":"reference/#StructPack.skip","page":"API Reference","title":"StructPack.skip","text":"skip(io::IO)\n\nSkip the msgpack value in io.\n\n\n\n\n\n","category":"function"},{"location":"reference/#StructPack.step","page":"API Reference","title":"StructPack.step","text":"step(io::IO)\n\nEnter or skip the msgpack value in io.\n\nIf the value is in map or vector format, step into it. Otherwise, skip the element.\n\nReturns the core format of the value skipped or stepped into.\n\nFor example, if a msgpack array is stored in io, then step(io); unpack(io) will (generically) unpack the first element of the array.\n\n\n\n\n\n","category":"function"},{"location":"macro/","page":"The @pack macro","title":"The @pack macro","text":"CurrentModule = StructPack","category":"page"},{"location":"macro/#The-@pack-macro","page":"The @pack macro","title":"The @pack macro","text":"","category":"section"},{"location":"macro/","page":"The @pack macro","title":"The @pack macro","text":"@pack","category":"page"},{"location":"macro/#StructPack.@pack","page":"The @pack macro","title":"StructPack.@pack","text":"@pack [context] target [in format] [(constructor...)] [{type parameters...}] [[formats...]]\n\nConvenience macro to generate packing / unpacking code for the types specified by target.\n\nArguments\n\ntarget\n\nThis argument has to be of the form T, {<: T}, or {S <: T}, where T is an existing type and S is a variable name that can be reused in the constructor (see below). This is the only mandatory argument of @pack.\n\ncontext\n\nThis (optional) argument has to be an existing subtype C <: Context, see Context. The generated code will be restricted to this context. Note that no instance of C can be passed; an actual type is required.\n\nformat\n\nThis (optional) pattern can be used to set the default format of the type target by specializing the function format. For instance, @pack T in F for F <: Format will define StructPack.format(::Type{T}) = F().\n\nThe special syntax F[C], where F <: Format and C <: Context, is available as shortcut for SetContextFormat{C, F}. This will mainly be useful for the specification of field and type-parameter formats via (formats...), see below.\n\nconstructor\n\nThis (optional) argument affects the functions destruct, construct, fieldnames, and (optionally) fieldtypes when a value of type T is packed / unpacked in a format F <: AbstractStructFormat.\n\nIt can be a list of (keyword) arguments like (a, b, ...; c, d, ...), in which case the constructor T is called with the respective arguments in construct.\nIt can be function call expression like f(a, b, ...; c, d, ...), in which case the function f is called with the respective arguments in construct.\n\nIn both cases, only the fields (:a, :b, ..., :c, :d, ...) are returned by fieldnames, in this order. This also affects which fields are packed via destruct.\n\nIf type specifications are present (e.g., (a::Int, b; c::Float64)), the respective field types returned by fieldtypes are overwritten.\n\ntype parameters\n\nThis (optional) argument affects the function typeparamtypes. It expects an expression of the form {A::Ta, B::Tb, ...}, where the labels A, B, ... are optional and Ta, Tb, ... indicate the type of the respective type parameter.\n\nSpecification of the type parameter types is necessary if T is to be packed / unpacked in TypeFormat or a value val::T is to be packed / unpacked in TypedFormat.\n\nAs a simple example, consider @pack Array {::Type, ::Int}, which enables packing / unpacking array types:\n\nbytes = pack(Array{Float64, 3})\nunpack(bytes, Type) # sucessfully returns Array{Float64, 3}\n\nformats\n\nThis (optional) argument affects the functions fieldformats and typeparamformats. It is expected to be a list of format specifications [a in Fa, b in Fb, C in FC, ...], where the labels a, b, C, ... refer to either field names of T or type parameter names established in the {type parameters...} argument, and where Fa, Fb, FC, ... are existing subtypes of Format (see in format above).\n\nFor convenience, the syntax [(a, b, ...) in F] translates to [a in F, b in F, ...].\n\nExamples\n\nusing StructPack\n\nstruct A\n  a :: Int\n  b :: Vector{Float64}\n  c :: Vector{Float64}\nend\n\nA(a, b) = A(a, b, rand(5))\n\n@pack A in StructFormat (a, b) [b in BinVectorFormat]\n\nA(a, b; c) = A(a, b, c)\n\n@pack A in StructFormat (a, b; c) [(b, c) in BinVectorFormat]\n\nmyA(a) = A(a, [], [])\n\n@pack A in StructFormat myA(a)\n\n\n\n\n\n","category":"macro"},{"location":"","page":"Overview","title":"Overview","text":"CurrentModule = StructPack","category":"page"},{"location":"#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"Welcome to the documentation of StructPack.jl.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"StructPack.jl is a julia package that lets you conveniently and efficiently serialize your julia structs in a way that is compatible to the binary msgpack standard.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"You can install it via executing","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"using Pkg; Pkg.add(\"StructPack\")","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"in a julia shell. Since it uses scoped values, it requires a julia version of 1.11 or newer.","category":"page"},{"location":"#Quickstart","page":"Overview","title":"Quickstart","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"The functionality of StructPack.jl centers around the functions pack and unpack to serialize and deserialize julia objects. How an object is mapped to its binary msgpack representation is controlled by the Format used during calls to pack and unpack. Default formats are specified via format.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"The following example uses the in-built StructFormat to automatically store the fields of A in the msgpack map format.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"using StructPack\n\nstruct A\n  a::Int\n  b::String\nend\n\nStructPack.format(::Type{A}) = StructFormat()\n\nbytes = pack(A(5, \"welcome!\"))\nunpack(bytes, A)","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"StructPack.jl offers a number of pre-defined formats for different scenarios.  See the Formats section of this documentation.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Consult Usage for a more in-depth exploration of the functionality of StructPack.jl, including an overview of the most important formats, the convenient auxiliary macro @pack, as well as ways to customize packing and unpacking via Context objects.","category":"page"}]
}
