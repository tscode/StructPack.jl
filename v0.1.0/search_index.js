var documenterSearchIndex = {"docs":
[{"location":"formats/","page":"Formats","title":"Formats","text":"CurrentModule = StructPack","category":"page"},{"location":"formats/#Formats","page":"Formats","title":"Formats","text":"","category":"section"},{"location":"formats/","page":"Formats","title":"Formats","text":"Format","category":"page"},{"location":"formats/#StructPack.Format","page":"Formats","title":"StructPack.Format","text":"Abstract format type.\n\nFormats determine the rules for packing and unpacking values via msgpack primitives. They are supposed to be singleton types.\n\nTo add support for a new format F <: Format, define the corresponding methods of pack and unpack.\n\nThis package comes with a number of built-in formats. The following core formats have low-level implementations that build upon one or more formats of the msgpack specification:\n\nNilFormat (msgpack nil),\nBoolFormat (msgpack boolean),\nSignedFormat (msgpack negative / positive fixint, signed 8-64),\nUnsignedFormat (msgpack positive fixint, unsigned 8-64),\nFloatFormat (msgpack float32, float64)\nStringFormat (msgpack fixstr, str 8-32),\nBinaryFormat (msgpack bin 16, bin 32).\n\nFor vector-like and map-like objects, several built-in formats with different benefits and drawbacks are provided as subtypes of\n\nAbstractVectorFormat (msgpack fixarray, array 16, array 32),\nAbstractMapFormat (msgpack fixmap, map 16, map 32).\n\nAdditional convenience formats include\n\nArrayFormat (store multidimensional arrays),\nBinVectorFormat (store vectors with bitstype elements efficiently),\nBinArrayFormat (store multidimensional bitstype arrays efficiently),\nTypeFormat (store types)\nTypedFormat (store values and their type for generic unpacking).\n\n\n\n\n\n","category":"type"},{"location":"formats/#Basic-Formats","page":"Formats","title":"Basic Formats","text":"","category":"section"},{"location":"formats/","page":"Formats","title":"Formats","text":"NilFormat\nBoolFormat\nSignedFormat\nUnsignedFormat\nFloatFormat\nStringFormat\nBinaryFormat","category":"page"},{"location":"formats/#StructPack.NilFormat","page":"Formats","title":"StructPack.NilFormat","text":"Core format for packing nil values.\n\nBuilt upon the msgpack format nil.\n\nDefaults\n\nNilFormat is the default format of Nothing. Use\n\nformat(::Type{T}) = NilFormat()\n\nor\n\n@pack T in NilFormat\n\nto make NilFormat the default format for type T. If T is abstract, use {<: T} to cover all subtypes.\n\nPacking\n\nAll types can be packed in NilFormat.\n\nUnpacking\n\nTo support unpacking values of type T packed in NilFormat, implement\n\nconstruct(::Type{T}, ::Nothing, ::NilFormat)::T\n\nor make sure that the constructor T() is defined.\n\n\n\n\n\n","category":"type"},{"location":"formats/#StructPack.BoolFormat","page":"Formats","title":"StructPack.BoolFormat","text":"Core format for packing boolean values.\n\nBuilt upon the msgpack format boolean.\n\nDefaults\n\nBoolFormat is the default format of Bool. Use\n\nformat(::Type{T}) = BoolFormat()\n\nor\n\n@pack T in BoolFormat\n\nto make BoolFormat the default format for type T. If T is abstract, use {<: T} to cover all subtypes.\n\nPacking\n\nTo support packing values of type T in BoolFormat, implement\n\ndestruct(val::T, ::BoolFormat)::Bool\n\nUnpacking\n\nTo support unpacking values of type T packed in BoolFormat, implement\n\nconstruct(::Type{T}, ::Bool, ::BoolFormat)::T\n\nor make sure that the constructor T(::Bool) is defined.\n\n\n\n\n\n","category":"type"},{"location":"formats/#StructPack.SignedFormat","page":"Formats","title":"StructPack.SignedFormat","text":"Core format for packing signed integer values.\n\nBuilt upon the msgpack formats negative fixint, positive fixint, signed 8, signed 16, signed 32, signed 64.\n\nDefaults\n\nSignedFormat is the default format of all subtypes of Signed. Use\n\nformat(::Type{T}) = SignedFormat()\n\nor\n\n@pack T in SignedFormat\n\nto make SignedFormat the default format for type T. If T is abstract, use {<: T} to cover all subtypes.\n\nPacking\n\nTo support packing values of type T in SignedFormat, implement\n\ndestruct(val::T, ::SignedFormat)::Signed\n\nUnpacking\n\nTo support unpacking values of type T packed in SignedFormat, implement\n\nconstruct(::Type{T}, ::Int64, ::SignedFormat)::T\n\nor make sure that the constructor T(::Int64) is defined.\n\n\n\n\n\n","category":"type"},{"location":"formats/#StructPack.UnsignedFormat","page":"Formats","title":"StructPack.UnsignedFormat","text":"Core format for packing unsigned integer values.\n\nBuilt upon the msgpack formats positive fixint, unsigned 8, unsigned 16, unsigned 32, unsigned 64.\n\nDefaults\n\nUnsignedFormat is the default format of all subtypes of Unsigned. Use\n\nformat(::Type{T}) = UnsignedFormat()\n\nor\n\n@pack T in UnsignedFormat\n\nto make UnsignedFormat the default format for type T. If T is abstract, use {<: T} to cover all subtypes.\n\nPacking\n\nTo support packing values of type T in UnsignedFormat, implement\n\ndestruct(val::T, ::UnsignedFormat)::Unsigned\n\nUnpacking\n\nTo support unpacking values of type T packed in UnsignedFormat,  implement\n\nconstruct(::Type{T}, ::UInt64, ::UnsignedFormat)::T\n\nor make sure that the constructor T(::UInt64) is defined.\n\n\n\n\n\n","category":"type"},{"location":"formats/#StructPack.FloatFormat","page":"Formats","title":"StructPack.FloatFormat","text":"Core format for packing float values.\n\nBuilt upon the msgpack formats float 32, float 64.\n\nDefaults\n\nFloatFormat is the default format for Float16, Float32, and Float64. Use\n\nformat(::Type{T}) = FloatFormat()\n\nor\n\n@pack T in FloatFormat\n\nto make FloatFormat the default format for type T. If T is abstract, use {<: T} to cover all subtypes.\n\nPacking\n\nTo support packing values of type T in FloatFormat, implement\n\ndestruct(val::T, ::FloatFormat)::Union{Float16, Float32, Float64}\n\nUnpacking\n\nTo support unpacking values of type T packed in FloatFormat,  implement\n\nconstruct(::Type{T}, ::Float64, ::FloatFormat)::T\n\nor make sure that the constructor T(::Float64) is defined.\n\n\n\n\n\n","category":"type"},{"location":"formats/#StructPack.StringFormat","page":"Formats","title":"StructPack.StringFormat","text":"Core format for packing string values.\n\nBuilt upon the msgpack formats fixstr, str 8, str 16, str 32.\n\nDefaults\n\nStringFormat is the default format for Symbol and all subtypes of AbstractString. Use\n\nformat(:: Type{T}) = StringFormat()\n\nor\n\n@pack T in StringFormat\n\nto make StringFormat the default format for type T. If T is abstract, use {<: T} to cover all subtypes.\n\nPacking\n\nTo support packing values of type T in StringFormat, implement\n\ndestruct(val::T, ::StringFormat)::R\n\nwhere the returned value ret::R must implement sizeof(ret) (number of bytes) as well as write(io, ret).\n\nUnpacking\n\nTo support unpacking values of type T packed in StringFormat, implement\n\nconstruct(:: Type{T}, ::String, ::StringFormat)::T\n\nor make sure that convert(T, ::String) is defined.\n\n\n\n\n\n","category":"type"},{"location":"formats/#StructPack.BinaryFormat","page":"Formats","title":"StructPack.BinaryFormat","text":"Core format for packing binary values.\n\nBuilt upon the msgpack formats bin 8, bin 16, bin 32.\n\nDefaults\n\nUse\n\nformat(::Type{T}) = BinaryFormat()\n\nor\n\n@pack T in BinaryFormat\n\nto make BinaryFormat the default format for type T. If T is abstract, use {<: T} to cover all subtypes.\n\nPacking\n\nTo support packing values of type T in BinaryFormat, implement\n\ndestruct(val::T, ::BinaryFormat)::R\n\nwhere the returned value ret::R must implement sizeof(ret) (number of bytes) as well as write(io, ret).\n\nUnpacking\n\nTo support unpacking values of type T packed in BinaryFormat,  implement\n\nconstruct(::Type{T}, ::Vector{UInt8}, ::BinaryFormat)::T\n\nor make sure that the constructor T(::Vector{UInt8}) is defined.\n\n\n\n\n\n","category":"type"},{"location":"formats/#Vector-and-Array-Formats","page":"Formats","title":"Vector and Array Formats","text":"","category":"section"},{"location":"formats/","page":"Formats","title":"Formats","text":"Besides VectorFormat, which mirrors the msgpack vector format, StructPack.jl also provides convenience formats for storing isbits-vectors and multidimensional arrays.","category":"page"},{"location":"formats/","page":"Formats","title":"Formats","text":"AbstractVectorFormat\nVectorFormat\nArrayFormat\nBinVectorFormat\nBinArrayFormat\nDynamicVectorFormat","category":"page"},{"location":"formats/#StructPack.AbstractVectorFormat","page":"Formats","title":"StructPack.AbstractVectorFormat","text":"Umbrella type for VectorFormat and DynamicVectorFormat.\n\n\n\n\n\n","category":"type"},{"location":"formats/#StructPack.VectorFormat","page":"Formats","title":"StructPack.VectorFormat","text":"Core format for packing vector values.\n\nBuilt upon the msgpack formats fixarray, array 16, array 32.\n\nDefaults\n\nVectorFormat is the default format for subtypes of Tuple and AbstractVector. Use\n\nformat(::Type{T}) = VectorFormat()\n\nor\n\n@pack T in VectorFormat\n\nto make VectorFormat the default format for type T. If T is abstract, use {<: T} to cover all subtypes.\n\nPacking\n\nTo support packing values of type T in VectorFormat, implement\n\ndestruct(val::T, ::VectorFormat)::R\n\nwhere the returned value ret::R must implement Base.length(ret) (number of entries) and must be iterable. The formats of the entries of val are determined via valueformat, where state is the linear index.\n\nUnpacking\n\nTo support unpacking values of type T packed in VectorFormat,  implement\n\nconstruct(::Type{T}, values::Generator{T}, ::VectorFormat)::T\n\nor make sure that the constructor T(values::Generator{T}) is defined (see Generator). The respective types and formats of the entries of values are determined via valuetype and valueformat, where state is the linear index.\n\nwarning: Warning\nDuring construction, all entries of the generator values have to be iterated over. Since Generator{T} wraps a lazy map that reads from the IO source to be unpacked, not conducting the iteration before the next object is processed will interfere with unpacking of subsequent values. For the same reason, you should not store the object values and access it at a later time.\n\n\n\n\n\n","category":"type"},{"location":"formats/#StructPack.ArrayFormat","page":"Formats","title":"StructPack.ArrayFormat","text":"Format for arrays that remembers the array size.\n\nBuilt upon VectorFormat.\n\nDefaults\n\nArrayFormat is the default format for AbstractArray. Use\n\nformat(::Type{T}) = ArrayFormat()\n\nor\n\n@pack T in ArrayFormat\n\nto make ArrayFormat the default format for type T. If T is abstract, use {<: T} to cover all subtypes.\n\nPacking\n\nTo support packing values of type T in ArrayFormat, implement\n\ndestruct(val::T, ::ArrayFormat)::R\n\nwhere the returned value ret::R must define size and must be packable in VectorFormat.\n\nUnpacking\n\nTo support unpacking values of type T packed in ArrayFormat, implement\n\nconstruct(::Type{T}, ::ArrayValue{Generator{T}}, ::ArrayFormat)::T\n\nor make sure that the constructor T(val::ArrayValue{Generator{T}}) is defined (see ArrayValue and Generator).\n\n\n\n\n\n","category":"type"},{"location":"formats/#StructPack.BinVectorFormat","page":"Formats","title":"StructPack.BinVectorFormat","text":"Pack vectors in binary format.  \n\nBuilt upon BinaryFormat.\n\nDefaults\n\nBinVectorFormat is the default format for BitVector. Use\n\nformat(::Type{T}) = BinVectorFormat()\n\nor\n\n@pack T in BinVectorFormat\n\nto make BinVectorFormat the default format for type T. If T is abstract, use {<: T} to cover all subtypes.\n\nPacking\n\nTo support packing values of type T in BinVectorFormat, implement\n\ndestruct(val::T, ::BinVectorFormat)::R\n\nwhere the returned value ret::R must be packable in BinaryFormat.\n\nUnpacking\n\nTo support unpacking values of type T packed in BinVectorFormat, implement\n\nconstruct(::Type{T}, ::Vector{UInt8}, ::BinVectorFormat)::T\n\nor make sure that the constructor T(bytes::Vector{UInt8}) is defined.\n\n\n\n\n\n","category":"type"},{"location":"formats/#StructPack.BinArrayFormat","page":"Formats","title":"StructPack.BinArrayFormat","text":"Pack arrays in binary format.  \n\nBuilt upon BinVectorFormat.\n\nDefaults\n\nBinArrayFormat is the default format for BitArray{N} for N > 1. Use\n\nformat(::Type{T}) = BinArrayFormat()\n\nor\n\n@pack T in BinArrayFormat\n\nto make BinVectorFormat the default format for type T. If T is abstract, use {<: T} to cover all subtypes.\n\nPacking\n\nTo support packing values of type T in BinArrayFormat, implement\n\ndestruct(val::T, ::BinArrayFormat)::R\n\nwhere the returned value ret::R must define Base.size and must be packable in BinaryFormat.\n\nUnpacking\n\nTo support unpacking values of type T packed in BinArrayFormat, implement\n\nconstruct(::Type{T}, ::BinArrayValue{Vector{UInt8}}, ::BinArrayFormat)::T\n\nor make sure that the constructor T(val::BinArrayValue{Vector{UInt8}}) is defined (see [BinArrayValue(@ref)]).\n\n\n\n\n\n","category":"type"},{"location":"formats/#StructPack.DynamicVectorFormat","page":"Formats","title":"StructPack.DynamicVectorFormat","text":"Modification of VectorFormat.\n\nDuring unpacking, the types and formats of future entries may depend on past entries via overloading iterstate.\n\ninfo: Info\nDynamicVectorFormat is currently slower than VectorFormat, even if iterstate just enumerates indices. In principle, however, the compiler should have all information neccessary to optimize DynamicVectorFormat in this case and bring the performance on par. In the future, we might thus deprecate DynamicVectorFormat and absorb its functionality into VectorFormat.\n\n\n\n\n\n","category":"type"},{"location":"formats/#Map-Formats","page":"Formats","title":"Map Formats","text":"","category":"section"},{"location":"formats/","page":"Formats","title":"Formats","text":"Besides the format MapFormat, which mirrors the msgpack map format, StructPack.jl also provides specialized map implementations for structures.","category":"page"},{"location":"formats/","page":"Formats","title":"Formats","text":"AbstractMapFormat\nMapFormat\nDynamicMapFormat\nAbstractStructFormat\nStructFormat\nUnorderedStructFormat","category":"page"},{"location":"formats/#StructPack.AbstractMapFormat","page":"Formats","title":"StructPack.AbstractMapFormat","text":"Umbrella type for MapFormat, DynamicMapFormat, and AbstractStructFormat.\n\n\n\n\n\n","category":"type"},{"location":"formats/#StructPack.MapFormat","page":"Formats","title":"StructPack.MapFormat","text":"Core format for packing map / dictionary values.\n\nBuilt upon the msgpack formats fixmap, map 16, map 32.\n\nDefaults\n\nMapFormat is the default format for subtypes of NamedTuple and Dict. Use\n\nformat(::Type{T}) = MapFormat()\n\nor\n\n@pack T in MapFormat\n\nto make MapFormat the default format for type T. If T is abstract, use {<: T} to cover all subtypes.\n\nPacking\n\nTo support packing values of type T in MapFormat, implement\n\ndestruct(val::T, ::MapFormat)::R\n\nwhere the returned value ret::R must implement Base.length(ret) (number of entries) and must be iterable with key-value pairs as entries. The key / value formats of the entries of val are determined via keyformat and valueformat, where state is the linear index.\n\nUnpacking\n\nTo support unpacking values of type T packed in MapFormat,  implement\n\nconstruct(::Type{T}, pairs::Generator{T}, ::MapFormat)::T\n\nor make sure that the constructor T(pairs::Generator{T}) is defined (see Generator), where pairs will contain key-value pairs as entries. The respective types and formats of the keys and values are determined during unpacking via keytype, valuetype, keyformat and valueformat, where state is the linear index.\n\nwarning: Warning\nDuring construction, all entries of the generator pairs have to be iterated over. Since Generator{T} wraps a lazy map that reads from the IO source to be unpacked, not conducting the iteration before the next object is processed will interfere with unpacking of subsequent values. For the same reason, you should not store the object pairs and access it at a later time.\n\n\n\n\n\n","category":"type"},{"location":"formats/#StructPack.DynamicMapFormat","page":"Formats","title":"StructPack.DynamicMapFormat","text":"Modification of MapFormat.\n\nDuring unpacking, the types and formats of future entries may depend on past entries via overloading iterstate.\n\ninfo: Info\nDynamicMapFormat is currently slower than MapFormat, even if iterstate just enumerates indices. In principle, however, the compiler should have all information neccessary to optimize DynamicMapFormat in this case and bring the performance on par. In the future, we might thus deprecate DynamicMapFormat and absorb its functionality into MapFormat.\n\n\n\n\n\n","category":"type"},{"location":"formats/#StructPack.AbstractStructFormat","page":"Formats","title":"StructPack.AbstractStructFormat","text":"Umbrella type for StructFormat and UnorderedStructFormat.\n\n\n\n\n\n","category":"type"},{"location":"formats/#StructPack.StructFormat","page":"Formats","title":"StructPack.StructFormat","text":"Format for packing structures.\n\nBuilt upon the msgpack formats fixmap, map 16, map 32.\n\nDefaults\n\nStructFormat is not used as default for any type. However, it should be the first candidate when you want to pack custom structs. Use\n\nformat(::Type{T}) = StructFormat()\n\nor\n\n@pack T in StructFormat\n\nto make StructFormat the default format for type T. If T is abstract, use {<: T} to cover all subtypes.\n\nPacking\n\nTo support packing values of type T in StructFormat, implement\n\ndestruct(val::T, ::MapFormat)::R\n\nwhere the returned value ret::R must implement Base.length(ret) (number of entries) and must be iterable with key-value pairs as entries.\n\nIn contrast to MapFormat, the keys are always stored in StringFormat and the value formats are determined via fieldformats, which should return a tuple of formats for the value-entries of the struct.\n\nUnpacking\n\nTo support unpacking values of type T packed in StructFormat,  implement\n\nconstruct(::Type{T}, pairs::Generator{T}, ::StructFormat)::T\n\nor make sure that the constructor T(values...) is defined, where values contains the value-entries of pairs.\n\nThe respective types and formats of the values are determined during unpacking via fieldtypes and fieldformats, which should return tuples of types and formats. Additionally, fieldnames is queried to make sure the keys encountered during unpacking are consistent with T.\n\nnote: StructFormat vs. MapFormat\nBoth StructFormat and MapFormat can be used to pack custom structs. They perform comparably.MapFormat is more flexible and can handle keys that are not symbols. In contrast, StructFormat requires static fieldtype, fieldname, and fieldformat information.\nHowever, MapFormat will not counter-check key values during unpacking and can thus easily lead to corrupted data if applied on external msgpack binaries.\n\n\n\n\n\n","category":"type"},{"location":"formats/#StructPack.UnorderedStructFormat","page":"Formats","title":"StructPack.UnorderedStructFormat","text":"Modification of StructFormat.\n\nThis map-based format automatically sorts entries according to fieldnames during unpacking.\n\nWhile the unpacking performance is deteriorated compared to StructFormat, this format makes it possible to load msgpack binaries where the order of map-entries cannot be guaranteed.\n\nBy default, the constructor T(values...) is used when unpacking a type T in UnorderedStructFormat, where values denotes the value-entries unpacked from the msgpack map. To use a keyword-argument based constructor, simply define\n\nconstruct(::Type{T}, pairs, ::UnorderedStructFormat) = T(; pairs...)\n\n\n\n\n\n","category":"type"},{"location":"formats/#Extra-Formats","page":"Formats","title":"Extra Formats","text":"","category":"section"},{"location":"formats/","page":"Formats","title":"Formats","text":"TypeFormat\nTypedFormat","category":"page"},{"location":"formats/#StructPack.TypeFormat","page":"Formats","title":"StructPack.TypeFormat","text":"Format that is used for packing types.\n\nIn order to pack and unpack a type T::Type in TypeFormat, you have to make sure that t = TypeValue(T) and composetype(t) work as intended.\n\n\n\n\n\n","category":"type"},{"location":"formats/#StructPack.TypedFormat","page":"Formats","title":"StructPack.TypedFormat","text":"Wrapper format for storing the value and type of an object.\n\nIf a value val::T can be packed in the format F<:Format and its type T can be packed in TypeFormat, then packing val in TypedFormat{F} enables unpacking via unpack(io, TypedFormat{F}()), i.e., without knowledge of T.\n\n\n\n\n\n","category":"type"},{"location":"formats/#Special-Formats","page":"Formats","title":"Special Formats","text":"","category":"section"},{"location":"formats/","page":"Formats","title":"Formats","text":"DefaultFormat\nAnyFormat","category":"page"},{"location":"formats/#StructPack.DefaultFormat","page":"Formats","title":"StructPack.DefaultFormat","text":"Special format that serves as lazy placeholder for format(T) in situations where the type T is not yet known.\n\nwarning: Warning\nNever define format(T) for a type T in terms of DefaultFormat. This will lead to indefinite recursion.\n\n\n\n\n\n","category":"type"},{"location":"formats/#StructPack.AnyFormat","page":"Formats","title":"StructPack.AnyFormat","text":"Convenience format to unpack generic msgpack values.\n\nNote that custom contexts (see Context) are ignored by AnyFormat.\n\nnote: Note\nmsgpack extensions and the date format are currently not supported by AnyFormat.\n\n\n\n\n\n","category":"type"},{"location":"usage/","page":"Usage","title":"Usage","text":"CurrentModule = StructPack","category":"page"},{"location":"usage/#Usage","page":"Usage","title":"Usage","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"In order to serialize or deserialize a value of type T via StructPack.jl, a format must be specified. A format is a singleton subtype of Format. This can either happen by explicitly providing it when calling pack and unpack, or by setting a default format via overloading format. Different formats might have different requirements for T.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"A number of basic julia types already have a default format associated to them and can be packed / unpacked without further instructions.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"using StructPack\n\nstr = \"This is a string\" # StringFormat by default\ntup = (\"tuple\", 5, false) # VectorFormat by default\nntup = (a = str, b = tup) # StructFormat by default\n\nbytes = pack(ntup)\nunpack(bytes, typeof(ntup))\n\n# or alternatively \n\nio = IOBuffer()\npack(io, ntup)\nseekstart(io)\nunpack(io, typeof(ntup))","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"When using StructPack is issued, the functions pack and unpack, the macro @pack, and a set of built-in formats is exported.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"The type information passed to unpack is needed, since no such information is stored in bytes. If it is left out, Pack.unpack(bytes) tries to load bytes as generic msgpack object and returns a dictionary (since ntup is stored in the msgpack map format). We will later see how type information can be stored as well, enabling generic unpacking.","category":"page"},{"location":"usage/#Custom-packing","page":"Usage","title":"Custom packing","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"StructPack.jl gives you several out-of-the-box options how to serialize a custom structure.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"struct MyStruct\n  a::Float64\n  b::String\nend\n\nStructPack.format(::Type{MyStruct}) = MapFormat()\n# or\nStructPack.format(::Type{MyStruct}) = StructFormat()\n# or\nStructPack.format(::Type{MyStruct}) = UnorderedStructFormat()\n# or\nStructPack.format(::Type{MyStruct}) = VectorFormat()\n\nbytes = pack(MyStruct(0., \"a string\"))","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"In the first three cases, the binary bytes will coincide. The difference lies in the unpacking: MapFormat will (by default) not check if the keys in bytes confirm to :a and :b. StructFormat, on the other hand, will perform such a consistency check. UnorderedStructFormat will also perform such a check. It is slower but can unpack msgpack binaries where the order of the entries are altered.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"bytes1 = pack((a = 0., b = \"a string\")) # coincides with bytes\nbytes2 = pack((ab = 0., ba = \"a string\"))\nbytes3 = pack((b = 0., a = \"a string\"))\n\n# All of these will work as intended\nunpack(bytes1, MyStruct, MapFormat())\nunpack(bytes1, MyStruct, StructFormat())\nunpack(bytes1, MyStruct, UnorderedStructFormat())\n\n# This will fail for StructFormat and UnorderedStructFormat\nunpack(bytes2, MyStruct, MapFormat())\n\n# This will not work as intended for MapFormat and will fail for StructFormat\nunpack(bytes3, MyStruct, UnorderedStructFormat())","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"If you choose VectorFormat, the keys :a and :b are not stored at all in bytes. Unpacking then only relies on the order of the arguments. In particular, pack(MyStruct(0., \"b\"), VectorFormat()) == pack([0., \"b\"]).","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"To make the specification of default formats more convenient, StructPack.jl also provides the macro @pack.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"@pack MyStruct in StructFormat\n# is equivalent to\nStructPack.format(::Type{MyStruct}) = StructFormat()","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"This macro has additional benefits: If you do not want to store all fields of MyStruct, or use a specific constructor when unpacking, you can easily inform @pack in combination with StructFormat or UnorderedStructFormat.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"# Special constructor we want to use during unpacking\nMyStruct(a; b) = MyStruct(a, b)\n@pack MyStruct in StructFormat (a; b)\n\n# or\n\n# We only want to serialize the field a\nMyStruct(a) = MyStruct(a, \"b is always the same\")\n@pack MyStruct in StructFormat (a,)","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"With a bit of additional code we have even more flexibility. For example, after we have decided to store only the field MyStruct.a::Float64 anyway, we could just directly use FloatFormat.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"StructPack.format(::Type{MyStruct}) = FloatFormat()\nStructPack.destruct(val::MyStruct, ::FloatFormat) = val.a\nStructPack.construct(val::MyStruct, a, ::FloatFormat) = MyStruct(a)","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"The functions destruct and construct are called before packing and after unpacking. Consult the docstrings of the various in-built formats to learn about their respective requirements for these functions.","category":"page"},{"location":"usage/#Parents-matter","page":"Usage","title":"Parents matter","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"StructPack.jl strives to be flexible when handling custom structs. In particular, it disagrees that a given value val::T should always be serialized in the same way, independent of the circumstances.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"There are two primary mechanism to enforce context-dependent customizations when packing and unpacking val: Via its parent structure, or via Context objects.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Here is a simple example where a field (the child) of a struct (the parent) receives a non-default format.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"struct MyOtherStruct\n  a::String           # Default format is StringFormat\n  b::Vector{Float32}  # Default format is VectorFormat\nend\n\n# We decide that MyStruct.b should rather be stored as binary vector\n@pack MyOtherStruct in StructFormat [b in BinVectorFormat]","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"The auxiliary format BinVectorFormat causes that MyOtherStruct.b will be stored in the msgpack binary format. Without further effort, this only works for types Vector{F} where isbitstype(F) is true.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Note that this call to @pack can be combined with the specification of a particular constructor (as above).","category":"page"},{"location":"usage/#Context-matters","page":"Usage","title":"Context matters","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"Another way to modify the format of a given value val::T are context objects, realized as singleton subtypes of Context. Context objects are particularly useful if you desired to change how val::T is serialized throughout (a part of) your code, but are reluctant to modify the global behavior for all values of type T. For example, T might belong to a third party package and you do not want to mess with its packing defaults.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"struct MyContext <: StructPack.Context end\n\n# Under MyContext, MyOtherStruct.b is packed in ArrayFormat\n# and the field order does not matter for unpacking\n@pack MyContext MyOtherStruct in UnorderedStructFormat [b in ArrayFormat]\n\nvalue = MyOtherStruct(\"Is my data stored in binary?\", rand(Float32, 10))\nbytes1 = pack(value, MyContext()) # ArrayFormat is used for field b\nbytes2 = pack(value)              # BinVectorFormat is used for field b\n\n# Unpacking must also get informed about the context\nunpack(bytes1, MyOtherStruct, MyContext())\nunpack(bytes2, MyOtherStruct)","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Here you have encountered ArrayFormat. This auxiliary format is able to store and recover (multidimensional) arrays by also storing the array size (see also BinArrayFormat).","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"For convenience, it is also possible to temporarily alter the default context for a block of code via the scoped value context.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"using Base.ScopedValues\n\nwith(StructPack.context=>MyContext()) do\n  bytes = pack(value) # ArrayFormat is used\n  unpack(bytes, MyOtherStruct)\nend","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Contexts can reach into and alter nearly each aspect of the serialization, as they penetrate into each packing related call (pack, unpack, format, ...). In general, to add a custom rule for your context, you can just overload the respective function with a trailing argument for the context. For example, the following are equivalent:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"@pack MyContext MyOtherStruct in StructFormat\n# and\nStructPack.format(::Type{MyOtherStruct}, ::MyContext) = StructFormat()","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Below, we discuss in more detail which functions are commonly overloaded when employing the @pack macro. ","category":"page"},{"location":"usage/#Contexts:-Case-study","page":"Usage","title":"Contexts: Case study","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"As mentioned above, contexts are useful to prevent the following uglyness: You want to serialize a type B.A from a package B in another way than the maintainers of package C want to serialize B.A. In general, the rule is to never set global default formats for types that you do not own. Always use the parent-mechanism or a dedicated context for such types.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"However, the main reason why I have included contexts into StructPack.jl is a different one. Imagine you want to save and load project files that capture some aspect of a program you are developing (think of a save state in a game). The first version, v1, might correspond directly to your project structure.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"struct Project\n  a::String\n  b::Int\n  c::Float64\nend\n\n@pack Project in StructFormat\n\nsaveproject(path, p::Project) = open(path, \"w\") do io\n  pack(io, p)\nend\n\nloadproject(path) = open(path, \"r\") do io\n  unpack(io, Project)\nend\n\nsaveproject(\"myproject.pack\", Project(\"test\", 5, 0.))","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Great! For version v2, however, you add a new feature and your project structure changes. It now looks like this:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"struct Project\n  c::Float64\n  b::Tuple{Int, Int}\n  a::String\n  d::Bool\nend","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"What to do with your now defunct project file myproject.pack? Of course, you could make up a mock structure ProjectV1 that mirrors the old format and provides a conversion function. Or you could just unpack myproject.pack as a dictionary and convert it back to a struct. ","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"In complicated settings, however, both of these options are cumbersome. This is especially true if several structs (that may be children of Project) change, maybe only slightly. You then either have to keep slight variations of countles struct copies around, or have to plow your way through nested dicts. The same horror continues with the next version v3.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Here, contexts in concert with the @pack macro become very useful.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"struct CompatV1V2 <: StructPack.Context end\n\nv1_to_v2(a, b, c) = Project(c, (b, b), a, false)\n\n@pack CompatV1V2 Project in StructFormat v1_to_v2(a, b::Int, c)\n\nloadproject_v2(path) = open(path, \"r\") do io\n  unpack(io, Project, CompatV1V2())\nend\n\np = loadproject_v2(\"myproject.pack\")","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Note that the context CompatV1V2 is \"ill-defined\", in that you cannot pack and consequtively unpack an object of type Project in it (since we had to lie about the type of Project.b, which is ignored by packing but respected by unpacking). However, we only need it for loading anway.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"The value of this approach might not be too apparent in this simple example, but its composability pays when Project contains nested custom structs. In fact, we could even handle renamed fields quite principled by specializing StructPack.fieldnames given the context CompatV1V2.","category":"page"},{"location":"usage/#A-world-without-macros","page":"Usage","title":"A world without macros","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"How does the @pack macro work? Under the hood, it just overloads relevant packing functions. This means that every effect achievable via @pack can quite easily be achieved without macro as well, albeit at the cost of more code.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"For example, the macro call","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"@pack C A in StructFormat (a, c::Tc; b) [b in Fb]","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"is essentially expanded to","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"StructPack.format(::Type{A}, ::C) = StructFormat()\n\nStructPack.destruct(val::A, ::C) = (val.a, val.c, val.b)\n\nfunction StructPack.construct(::Type{A}, pairs, ::C)\n  args = (pairs[1][2], pairs[2][2])\n  kwargs = (pairs[3],)\n  A(args...; kwargs...)\nend\n\nStructPack.fieldnames(::Type{A}, ::C) = (:a, :c, :b)\n\nfunction StructPack.fieltypes(::Type{A}, ::C)\n  # This is actually solved via a generated function, so the calls to fieldtype\n  # take place before compile time\n  (fieldtype(A, :a), Tc, fieldtype(A, :b))\nend\n\nfunction StructPack.fieldformats(::Type{A}, ::C)\n  (DefaultFormat(), DefaultFormat(), Fb())\nend","category":"page"},{"location":"usage/#Exploring-the-Abstract","page":"Usage","title":"Exploring the Abstract","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"Until now, we have only considered unpacking when we knew the concrete type of our object beforehand. This implies heavy limitations. For example, what would we do in the following situation?","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"abstract type Vehicle end\n\nstruct Boat <: Vehicle\n  a::Int\nend\n\nstruct Train <: Vehicle\n  b::Float64\nend\n\nstruct Ticket\n  price::Float64\n  vehicle::Vehicle\nend","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Here we have to call unpack(..., Vehicle) at some point, which clearly does not tell us about the underlying msgpack layout beforehand. To resolve this issue, it is necessary that some type information is stored alongside the value.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"In StructPack.jl, this problem is solved via the special auxiliary format TypedFormat.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"@pack {<: Vehicle} in TypedFormat{StructFormat}\n\nbytes = pack(Boat(42)) # This will be a lot of bytes...\nunpack(bytes, Vehicle) # ... but this will work!","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Now, packing a value of type Vehicle will actually store a msgpack map with the two keys :type and :value, the first of which contains type information sufficient to reconstruct the concrete type. The value stored behind the key :value will be formatted in StructFormat.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"This is very convenient. However, you should realize that we approach potentially dangerous territory here. This is true in at least two respects:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"The performance of packing and unpacking suffers considerably when using TypedFormat. This means that you should probably avoid storing lots and lots of values in this format. \nUnpacking in TypedFormat is potentially unsafe, since arbitrary constructors could be triggered. Care is taken that eval is never called, and that the type in question is a subtype of Vehicle, BUT when storing and restoring type parameters (e.g., the F in Vector{F}), the default behavior is that any type could be reconstructed, meaning that any constructor could be called if malicious data is unpacked in this format.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"The second of these issue (arbitrary constructor evaluation) is arguably better than plain old arbitrary code execution, but it is still unacceptable in sensitive settings. For that reason, the user is given fine grained control about which constructors are allowed to be executed via the scoped value whitelist.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"For example, when you call","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"using ScopedValues\n\nwith(StructPack.whitelist=>[Vehicle])\n  unpack(bytes, Vehicle)\nend","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"only the construct routines of subtypes of Vehicle are allowed when performing unpacking in TypedFormat. Alternatively, whitelists can also be defined via singleton subtypes of Whitelist in combination with whitelisted.","category":"page"},{"location":"context/","page":"Context","title":"Context","text":"CurrentModule = StructPack","category":"page"},{"location":"context/#Context","page":"Context","title":"Context","text":"","category":"section"},{"location":"context/","page":"Context","title":"Context","text":"Context\nDefaultContext","category":"page"},{"location":"context/#StructPack.Context","page":"Context","title":"StructPack.Context","text":"Abstract serialization context.\n\nA context can be introduced to temporarily enforce custom behavior when packing and unpacking values.\n\nIn particular, a context can influence which formats are assigned to types (via format) or to fields of a struct (via valueformat). It can also influence how objects are processed before packing and after unpacking (via destruct and construct).\n\n\n\n\n\n","category":"type"},{"location":"context/#StructPack.DefaultContext","page":"Context","title":"StructPack.DefaultContext","text":"Context that directs packing / unpacking towards fallback implementations.\n\nThis is an auxiliary type and should not come into contact with users of the package.\n\nwarning: Warning\nDo not dispatch on ::DefaultContext to provide global defaults. Always use Context-free methods for this purpose. For example, use format(::Type{MyType}) = ... instead of format(::Type{MyType}, ::DefaultContext) = ... to set a default format for MyType.\n\n\n\n\n\n","category":"type"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"CurrentModule = StructPack","category":"page"},{"location":"reference/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"reference/#Main-API","page":"API Reference","title":"Main API","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"format\npack\nunpack\nconstruct\ndestruct","category":"page"},{"location":"reference/#StructPack.format","page":"API Reference","title":"StructPack.format","text":"format(T::Type [, ctx::Context])::Format\nformat(::T [, ctx::Context])::Format\n\nReturn the format associated to type T under ctx.\n\nThe context-free version of this method must be implemented in order for pack(io, value::T) and unpack(io, T) to work. It is used as fallback for all contexts.\n\nSee also Format and DefaultFormat.\n\n\n\n\n\n","category":"function"},{"location":"reference/#StructPack.pack","page":"API Reference","title":"StructPack.pack","text":"pack(value, [, ctx::Context])::Vector{UInt8}\npack(value, [, fmt::Format, ctx::Context])::Vector{UInt8}\npack(io::IO, args...)::Nothing\n\nCreate a binary msgpack representation of value according to the given format fmt. If a stream io is passed, the representation is written into it.\n\nIf no format is provided, it is derived from the type of value via format(typeof(value), ctx). The context defaults to the scoped value context.\n\nIf both a format and a context is provided, fmt is used for packing value while ctx is passed along to deeper packing related calls.\n\n\n\n\n\n","category":"function"},{"location":"reference/#StructPack.unpack","page":"API Reference","title":"StructPack.unpack","text":"unpack(bytes::Vector{UInt8}, T::Type [, ctx::Context])::T\nunpack(bytes::Vector{UInt8}, T::Type [, fmt::Format, ctx:::Context])::T\nunpack(io::IO, T::Type, args...)::T\n\nUnpack a binary msgpack representation of a value of type T in format fmt from a byte vector bytes or a stream io. The returned value is guaranteed to be of type T.\n\nIf no format is provided, it is derived from T via format(T, ctx). The context ctx defaults to context.\n\n\n\n\n\nunpack(bytes::Vector{UInt8})::Any\nunpack(io::IO)::Any\n\nUnpack a binary msgpack value via the special format AnyFormat. The returned value can be of any type.\n\n\n\n\n\n","category":"function"},{"location":"reference/#StructPack.construct","page":"API Reference","title":"StructPack.construct","text":"construct(T::Type, val, fmt::Format [, ctx::Context])::T\n\nPostprocess a value val unpacked according to fmt and return an object of type T. The type of val depends on the format fmt that was used for unpacking.\n\nDefaults to T(val) but can be overwritten for any combination of T, fmt, and ctx.\n\n\n\n\n\n","category":"function"},{"location":"reference/#StructPack.destruct","page":"API Reference","title":"StructPack.destruct","text":"destruct(val::T, fmt::Format [, ctx::Context])\n\nPreprocess a value val to prepare packing it in the format fmt.\n\nDefaults to val but can be overwritten for any combination of T, fmt, and ctx.\n\nEach format has specific requirements regarding the output of this method.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Keys-and-values","page":"API Reference","title":"Keys and values","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"keytype\nkeyformat\nvaluetype\nvalueformat\niterstate","category":"page"},{"location":"reference/#StructPack.keytype","page":"API Reference","title":"StructPack.keytype","text":"keytype(T::Type, state, fmt::Format [, ctx::Context])::Type\n\nReturn the type of the key at iteration state state when saving the entries of T in format fmt.\n\nThis method is called when unpacking values in AbstractMapFormat.\n\n\n\n\n\n","category":"function"},{"location":"reference/#StructPack.keyformat","page":"API Reference","title":"StructPack.keyformat","text":"keyformat(T::Type, state, fmt::Format [, ctx::Context])::Format\n\nReturn the format of the key at iteration state state when saving the entries of T in format fmt.\n\nThis method is called when packing or unpacking values in AbstractMapFormat.\n\n\n\n\n\n","category":"function"},{"location":"reference/#StructPack.valuetype","page":"API Reference","title":"StructPack.valuetype","text":"valuetype(T::Type, fmt::Format, state [, ctx::Context])::Type\n\nReturn the type of the value at iteration state state when saving the entries of T in format fmt.\n\nThis method is used when unpacking values in AbstractVectorFormat and AbstractMapFormat.\n\n\n\n\n\n","category":"function"},{"location":"reference/#StructPack.valueformat","page":"API Reference","title":"StructPack.valueformat","text":"valueformat(T::Type, state, fmt::Format [, ctx::Context])::Format\n\nReturn the format of the value at iteration state state when saving the entries of T in format fmt.\n\nThis method is used when packing or unpacking values in AbstractVectorFormat and AbstractMapFormat.\n\n\n\n\n\n","category":"function"},{"location":"reference/#StructPack.iterstate","page":"API Reference","title":"StructPack.iterstate","text":"iterstate(T::Type, fmt::Format [, ctx::Context])\n\nInitialize a state object that is repeatedly updated while iterating over the entries of values of type T when packing and unpacking in format fmt.\n\nBy default, the initial state is 1 and gets replaced by state + 1 in subsequent updates.\n\nThis function is only relevant for formats that dynamically make use of the methods keytype, keyformat, valuetype, or valueformat, like DynamicVectorFormat and DynamicMapFormat.\n\n\n\n\n\niterstate(T::Type, state, entry, fmt::Format [, ctx::Context])\n\nReturn an update of the state object state when T is packed or unpacked in the format fmt.\n\nThe argument entry signifies the entry packed / unpacked in the last iteration and can be used to inform the next iteration state. It will be of type valuetype(T, fmt, state, ctx) in case of DynamicVectorFormat and similarly a key-value pair with types determined by keytype and valuetype in case of DynamicMapFormat.\n\nThis approach enables 'dynamic' unpacking where the type / format of an entry depends on the values unpacked previously. The format TypedFormat exploits this pattern.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Struct-fields","page":"API Reference","title":"Struct fields","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"fieldformats\nfieldtypes\nfieldnames","category":"page"},{"location":"reference/#StructPack.fieldformats","page":"API Reference","title":"StructPack.fieldformats","text":"fieldformats(T::Type [, ctx::Context])\n\nReturn the field types of T when packing / unpacking in AbstractStructFormat under ctx.\n\n\n\n\n\n","category":"function"},{"location":"reference/#StructPack.fieldtypes","page":"API Reference","title":"StructPack.fieldtypes","text":"fieldtypes(T::Type [, ctx::Context])\n\nReturn the field types of T when packing / unpacking in AbstractStructFormat under ctx.\n\nDefaults to Base.fieldtypes(T).\n\n\n\n\n\n","category":"function"},{"location":"reference/#StructPack.fieldnames","page":"API Reference","title":"StructPack.fieldnames","text":"fieldnames(T::Type [, ctx::Context])\n\nReturn the field names of T when packing / unpacking in AbstractStructFormat under ctx.\n\nDefaults to Base.fieldnames(T).\n\n\n\n\n\n","category":"function"},{"location":"reference/#Auxiliary-types","page":"API Reference","title":"Auxiliary types","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Generator\nArrayValue\nBinArrayValue\nTypeValue\nTypedValue","category":"page"},{"location":"reference/#StructPack.Generator","page":"API Reference","title":"StructPack.Generator","text":"Auxiliary object for unpacking sequential values.\n\nImplements the Base iterator interface and can for most purposes be treated like a Base.Generator. Compared to the latter, it is equipped with additional element type information via its first type parameter T.\n\nIn particular, when unpacking a value of type Generator{T} in VectorFormat or MapFormat, the methods valuetype, valueformat, keytype, and keyformat are called with type argument T to determine how elements are unpacked.\n\n\n\n\n\n","category":"type"},{"location":"reference/#StructPack.ArrayValue","page":"API Reference","title":"StructPack.ArrayValue","text":"Wrapper struct employed when unpacking a value in ArrayFormat.\n\nContains the fields size and data, the latter of which is usually a Generator after reconstruction via unpack.\n\n\n\n\n\n","category":"type"},{"location":"reference/#StructPack.BinArrayValue","page":"API Reference","title":"StructPack.BinArrayValue","text":"Wrapper object for unpacking values in BinArrayFormat.\n\nContains the fields size and data, the latter of which is a Vector{UInt8} after reconstruction via unpack.\n\n\n\n\n\n","category":"type"},{"location":"reference/#StructPack.TypeValue","page":"API Reference","title":"StructPack.TypeValue","text":"Auxiliary structure that expresses a type in a format friendly to serialization.\n\n\n\n\n\n","category":"type"},{"location":"reference/#StructPack.TypedValue","page":"API Reference","title":"StructPack.TypedValue","text":"Auxiliary structure that expresses a value and its type in a format friendly to serialization.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Typed-format","page":"API Reference","title":"Typed format","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"typeparamtype\ntypeparamformat\nWhitelist\nPermissiveWhitelist\nwhitelisted","category":"page"},{"location":"reference/#StructPack.typeparamtype","page":"API Reference","title":"StructPack.typeparamtype","text":"typeparamtype(T::Type, index , ::Format[, ::Context])\n\nReturn the type of the index-th type parameter of T.\n\nDefaults to Any.\n\nThis method is consulted when packing / unpacking types via TypeFormat and TypedFormat. It can be used to insert information about the type parameters of T.\n\n\n\n\n\n","category":"function"},{"location":"reference/#StructPack.typeparamformat","page":"API Reference","title":"StructPack.typeparamformat","text":"typeparamformat(T::Type, index, fmt::Format [, ctx::Context])\n\nReturn the type param format of the index-th type parameter of T\n\nDefaults to TypedFormat().\n\nThis method is consulted when packing / unpacking types via TypeFormat and [TypedFormat]. It can be used to insert information about the type parameters of T.\n\nThis method is called by valueformat(TypeParams{T}, fmt, index, ctx).\n\n\n\n\n\n","category":"function"},{"location":"reference/#StructPack.Whitelist","page":"API Reference","title":"StructPack.Whitelist","text":"Whitelist type.\n\nA whitelist can be activated via assigning a whitelist object (or a list of types) to the scoped value StructPack.whitelist.\n\n\n\n\n\n","category":"type"},{"location":"reference/#StructPack.PermissiveWhitelist","page":"API Reference","title":"StructPack.PermissiveWhitelist","text":"Default whitelist that permits any constructor when unpacking in TypedFormat.\n\n\n\n\n\n","category":"type"},{"location":"reference/#StructPack.whitelisted","page":"API Reference","title":"StructPack.whitelisted","text":"whitelisted(w, T::Type)\n\nCheck whether calling constructors of T is permitted according to the whitelist w.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Scoped-values","page":"API Reference","title":"Scoped values","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"context\nwhitelist","category":"page"},{"location":"reference/#StructPack.context","page":"API Reference","title":"StructPack.context","text":"Scoped value that captures the active context.\n\nTo pack / unpack in a given context ctx::Context, you can use this pattern:\n\nusing Base.ScopedValues\n\nwith(StructPack.context => ctx) do\n  # Do your packing / unpacking without passing ctx explicitly\n  # ...\nend\n\n\n\n\n\n","category":"constant"},{"location":"reference/#StructPack.whitelist","page":"API Reference","title":"StructPack.whitelist","text":"Scoped value that captures the active whitelist.\n\nIt can either be of type Whitelist, configurable via overloading whitelisted, or a vector of accepted (super-)types.\n\nIt defaults to an instance of PermissiveWhitelist.\n\nFor example, it can be employed as follows:\n\nusing Base.ScopedValues\n\nwith(StructPack.whitelist => [T1, T2, ...])\n  # All unpacking in TypedFormat in this block can only\n  # construct subtypes of T1, T2, ...\n  # ...\nend\n\n\n\n\n\n","category":"constant"},{"location":"macro/","page":"The @pack macro","title":"The @pack macro","text":"CurrentModule = StructPack","category":"page"},{"location":"macro/#The-@pack-macro","page":"The @pack macro","title":"The @pack macro","text":"","category":"section"},{"location":"macro/","page":"The @pack macro","title":"The @pack macro","text":"@pack","category":"page"},{"location":"macro/#StructPack.@pack","page":"The @pack macro","title":"StructPack.@pack","text":"@pack T in F\n@pack {<: T} in F\n\nConvenience syntax for StructPack.format(::Type{T}) = F() respectively StructPack.format(::Type{<: T}) = F().\n\n\n\n@pack C T in F\n@pack C {<: T} in F\n\nConvenience syntax for StructPack.format(::Type{T}, ::C) = F() respectively StructPack.format(::Type{<: T}, ::C) = F(), where C <: Context is the type of a context singleton.\n\n\n\n@pack C informat (constructor args...) [field formats...]\n\nGeneric packing macro for struct formats.\n\nThe first expression C <: Context is optional. The definitions enacted by the macro will be restricted to the context C().\n\nThe second expression informat can be an expression of the form T in F or {<: T} in F for a user specified type T and a given format type F <: Format.\n\nThe (optional) constructor expression can take one of the forms\n\n(a, ...; b, ...), which implies a constructor T(val_a, ...; c = val_c, ...) respectively S(val_a, ...; c = val_c, ...) where {S <: T} denotes a concrete subtype of T. The entries a, b, ... are expected to correspond to valid fieldnames of T (respectively S).\nA(a, ...; b, ...) for a custom constructor object / function A. Note that this call to A must return an object of type T (respectively S).\n\nThe (optional) field format expression is of the form [a => Fa, b => Fb, ...], where a, b, ... denote fieldnames and Fa, Fb, ... the corresponding field format. For convenience, it is also possible to specify one format F for several keys a, b, ... via the syntax [(a, b, ...) in F].\n\nwarning: Warning\nThe constructor and field format customizations that this macro offers are only effectful for StructFormat and UnorderedStructFormat. Thus, it only works as intended if the specified format F is built upon one of these formats (e.g., F = StructFormat or F = TypedFormat{UnorderedStructFormat}).\n\nExamples\n\nusing StructPack\n\nstruct A\n  a :: Int\n  b :: Vector{Float64}\n  c :: Vector{Float64}\nend\n\nA(a, b) = A(a, b, rand(5))\n\n@pack A in StructFormat (a, b) [b in BinVectorFormat]\n\nA(a, b; c) = A(a, b, c)\n\n@pack A in StructFormat (a, b; c) [(b, c) in BinVectorFormat]\n\nmyA(a) = A(a, [], [])\n\n@pack A in StructFormat myA(a)\n\n\n\n\n\n","category":"macro"},{"location":"","page":"Overview","title":"Overview","text":"CurrentModule = StructPack","category":"page"},{"location":"#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"Welcome to the documentation of StructPack.jl.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"StructPack.jl is a julia package that lets you conveniently and efficiently serialize your julia structs in a way that is compatible to the binary msgpack standard.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"You can install it via executing","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"using Pkg; Pkg.add(\"StructPack\")","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"in a julia shell. Since it uses scoped values, it requires a julia version of 1.11 or newer.","category":"page"},{"location":"#Quickstart","page":"Overview","title":"Quickstart","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"The functionality of StructPack.jl centers around the functions pack and unpack to serialize and deserialize julia objects. How an object is mapped to its binary msgpack representation is controlled by the Format used during calls to pack and unpack. Default formats are specified via format.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"The following example uses the in-built StructFormat to automatically store the fields of A in the msgpack map format.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"using StructPack\n\nstruct A\n  a::Int\n  b::String\nend\n\nStructPack.format(::Type{A}) = StructFormat()\n\nbytes = pack(A(5, \"welcome!\"))\nunpack(bytes, A)","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"StructPack.jl offers a number of pre-defined formats for different scenarios.  See the Formats section of this documentation.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Consult Usage for a more in-depth exploration of the functionality of StructPack.jl, including an overview of the most important formats, the convenient auxiliary macro @pack, as well as ways to customize packing and unpacking via Context objects.","category":"page"}]
}
